<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python," />





  <link rel="alternate" href="/atom.xml" title="whistlestop" type="application/atom+xml" />






<meta name="description" content="Putting a Wrapper Around a FunctionIf you ever need to wrap a function with extra code, define a decorator function.  123456789101112&amp;gt;&amp;gt;&amp;gt; import time&amp;gt;&amp;gt;&amp;gt; from functools import wraps&amp;gt">
<meta name="keywords" content="python">
<meta property="og:type" content="article">
<meta property="og:title" content="C09_Metaprogramming">
<meta property="og:url" content="blog.whistlestop.ml/2018/12/15/C09-Metaprogramming/index.html">
<meta property="og:site_name" content="whistlestop">
<meta property="og:description" content="Putting a Wrapper Around a FunctionIf you ever need to wrap a function with extra code, define a decorator function.  123456789101112&amp;gt;&amp;gt;&amp;gt; import time&amp;gt;&amp;gt;&amp;gt; from functools import wraps&amp;gt">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-12-15T11:12:08.284Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C09_Metaprogramming">
<meta name="twitter:description" content="Putting a Wrapper Around a FunctionIf you ever need to wrap a function with extra code, define a decorator function.  123456789101112&amp;gt;&amp;gt;&amp;gt; import time&amp;gt;&amp;gt;&amp;gt; from functools import wraps&amp;gt">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="blog.whistlestop.ml/2018/12/15/C09-Metaprogramming/"/>





  <title>C09_Metaprogramming | whistlestop</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">whistlestop</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Never start something you're not willing to finish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="blog.whistlestop.ml/2018/12/15/C09-Metaprogramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="eustoma">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="whistlestop">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C09_Metaprogramming</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T18:46:45+08:00">
                2018-12-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-12-15T19:12:08+08:00">
                2018-12-15
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/book-notes/" itemprop="url" rel="index">
                    <span itemprop="name">book notes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Putting-a-Wrapper-Around-a-Function"><a href="#Putting-a-Wrapper-Around-a-Function" class="headerlink" title="Putting a Wrapper Around a Function"></a>Putting a Wrapper Around a Function</h2><p>If you ever need to wrap a function with extra code, define a decorator function. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        start= time.time()</span><br><span class="line"><span class="meta">... </span>        result= func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        end= time.time()</span><br><span class="line"><span class="meta">... </span>        print(func.__name__, end- start)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<a id="more"></a> 
<p>Here is an example of using the decorator:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@timethis</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        n-= <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">100000</span>)</span><br><span class="line">countdown <span class="number">0.012996196746826172</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">10000000</span>)</span><br><span class="line">countdown <span class="number">0.8619716167449951</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>The return value of a decorator is almost always the result of calling <strong>func(*args, **kwargs)</strong>, where <strong>func</strong> is the original unwrapped function.</p>
<p>The use of the decorator <strong>@wraps(func)</strong> in the solution is an easy to forget but important technicality related to preserving function metadata.</p>
<h2 id="Preserving-Function-Metadata-When-Writing-Decorators"><a href="#Preserving-Function-Metadata-When-Writing-Decorators" class="headerlink" title="Preserving Function Metadata When Writing Decorators"></a>Preserving Function Metadata When Writing Decorators</h2><p>Whenever you define a decorator, you should always remember to apply the <strong>@wraps</strong> decorator from the <strong>functools</strong> library to the underlying wrapper function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@timethis</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n:int)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    Counts down</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    '''</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        n -= <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">100000</span>)</span><br><span class="line">countdown <span class="number">0.008917808532714844</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__name__</span><br><span class="line"><span class="string">'countdown'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__doc__</span><br><span class="line"><span class="string">'\n\tCounts down\n\t'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__annotations__</span><br><span class="line">&#123;<span class="string">'n'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;&#125;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>Copying decorator metadata is an important part of writing decorators. If you forget to use <strong>@wraps</strong>, you’ll find that the decorated function loses all sorts of useful information. For instance, if omitted, the metadata in the last example would look like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__name__</span><br><span class="line"><span class="string">'wrapper'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__doc__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__annotations__</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>An important feature of the <strong>@wraps</strong> decorator is that it makes the wrapped function available to you in the <strong>__wrapped__</strong> attribute.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__wrapped__(<span class="number">100000</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>The presence of the <strong>__wrapped__</strong> attribute also makes decorated functions properly expose the underlying signature of the wrapped function. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(signature(countdown))</span><br><span class="line">(n:int)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Unwrapping-a-Decorator"><a href="#Unwrapping-a-Decorator" class="headerlink" title="Unwrapping a Decorator"></a>Unwrapping a Decorator</h2><p>Assuming that the decorator has been implemented properly using <strong>@wraps</strong>, you can usually gain access to the original function by accessing the <strong>__wrapped__</strong> attribute. </p>
<p>If multiple decorators have been applied to a function, the behavior of accessing <strong>__wrapped__</strong> is currently undefined and should probably be avoided.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Decorator 1'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Decorator 2'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@decorator1</span><br><span class="line"><span class="meta">... </span>@decorator2</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span> <span class="keyword">return</span> x+ y</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Decorator <span class="number">1</span></span><br><span class="line">Decorator <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.__wrapped__(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Decorator <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.__wrapped__.__wrapped__(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>Be aware that not all decorators utilize <strong>@wraps</strong>, and thus, they may not work as described. In particular, the built-in decorators <strong>@staticmethod</strong> and <strong>@classmethod</strong> create descriptor objects that don’t follow this convention (instead, they store the original function in a <strong>__func__</strong> attribute).</p>
<h2 id="Defining-a-Decorator-That-Takes-Arguments"><a href="#Defining-a-Decorator-That-Takes-Arguments" class="headerlink" title="Defining a Decorator That Takes Arguments"></a>Defining a Decorator That Takes Arguments</h2><p>Suppose you want to write a decorator that adds logging to a function, but allows the user to specify the logging level and other details as arguments. Here is how you might define the decorator:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> logging</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name= None, message= None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Add logging to a function. level is the logging</span></span><br><span class="line"><span class="string"><span class="meta">... </span> level, name is the logger name, and message is the</span></span><br><span class="line"><span class="string"><span class="meta">... </span> log message. If name and message aren't specified,</span></span><br><span class="line"><span class="string"><span class="meta">... </span> they default to the function's module and name.</span></span><br><span class="line"><span class="string"><span class="meta">... </span> '''</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>        logname= name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line"><span class="meta">... </span>        log= logging.getLogger(logname)</span><br><span class="line"><span class="meta">... </span>        logmsg= message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"><span class="meta">... </span>        </span><br><span class="line"><span class="meta">... </span>        @wraps(func)</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>            log.log(level, logmsg)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> decorate</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The outermost function <strong>logged()</strong> accepts the desired arguments and simply makes them available to the inner functions of the decorator. The inner function <strong>decorate()</strong> accepts a function and puts a wrapper around it as normal. The key part is that the wrapper is allowed to use the arguments passed to <strong>logged()</strong>.</p>
<h2 id="Defining-a-Decorator-with-User-Adjustable-Attributes"><a href="#Defining-a-Decorator-with-User-Adjustable-Attributes" class="headerlink" title="Defining a Decorator with User Adjustable Attributes"></a>Defining a Decorator with User Adjustable Attributes</h2><p>You want to write a decorator function that wraps a function, but has user adjustable attributes that can be used to control the behavior of the decorator at runtime.</p>
<p>Here is a solution that expands on the last recipe by introducing accessor functions that change internal variables through the use of <strong>nonlocal</strong> variable declarations. The accessor functions are then attached to the wrapper function as function attributes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">attach_wrapper</span><span class="params">(obj, func= None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> partial(attach_wrapper, obj)</span><br><span class="line"><span class="meta">... </span>    setattr(obj, func.__name__, func)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> func</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name= None, message= None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>        logname= name <span class="keyword">if</span> name <span class="keyword">else</span> func.__name__</span><br><span class="line"><span class="meta">... </span>        log= logging.getLogger(logname)</span><br><span class="line"><span class="meta">... </span>        logmsg= message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>        @wraps(func)</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>            log.log(level, logmsg)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        @attach_wrapper(wrapper)</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">set_level</span><span class="params">(newlevel)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> level</span><br><span class="line"><span class="meta">... </span>            level= newlevel</span><br><span class="line"><span class="meta">... </span>        @attach_wrapper(wrapper)</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">set_message</span><span class="params">(newmsg)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> logmsg</span><br><span class="line"><span class="meta">... </span>            logmsg= newmsg</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> decorate</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Here is an interactive session that shows the various attributes being changed after definition:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@logged(logging.DEBUG)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+y</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logging.basicConfig(level= logging.DEBUG)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">DEBUG:add:add</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.set_message(<span class="string">'Add called'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">DEBUG:add:Add called</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.set_level(logging.WARNING)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">WARNING:add:Add called</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>The key to this recipe lies in the accessor functions [e.g., <strong>set_message()</strong> and <strong>set_level()</strong>] that get attached to the wrapper as attributes. Each of these accessors allows internal parameters to be adjusted through the use of <strong>nonlocal</strong> assignments.</p>
<p>An amazing feature of this recipe is that the accessor functions will propagate through multiple levels of decoration (if all of your decorators utilize <a href="mailto:**@functools.wraps" target="_blank" rel="noopener">**@functools.wraps</a>**).<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt; <span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        start= time.time()</span><br><span class="line"><span class="meta">... </span>        result= func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        end= time.time()</span><br><span class="line"><span class="meta">... </span>        print(func.__name__, end- start)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@timethis</span><br><span class="line"><span class="meta">... </span>@logged(logging.DEBUG)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        n-= <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">10000</span>)</span><br><span class="line">DEBUG:countdown:countdown</span><br><span class="line">countdown <span class="number">0.0149993896484375</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.set_level(logging.WARNING)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.set_message(<span class="string">'Counting down to 0'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">10000</span>)</span><br><span class="line">WARNING:countdown:Counting down to <span class="number">0</span></span><br><span class="line">countdown <span class="number">0.0010001659393310547</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>You’ll also find that it all still works exactly the same way if the decorators are composed in the opposite order, like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"> <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"> n -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>One extremely subtle facet of this recipe is the choice to use accessor functions in the first place. For example, you might consider an alternative formulation solely based on direct access to function attributes like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@wraps(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    wrapper.log.log(wrapper.level, wrapper.logmsg)</span><br><span class="line">    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="comment"># Attach adjustable attributes</span></span><br><span class="line">wrapper.level = level</span><br><span class="line">wrapper.logmsg = logmsg</span><br><span class="line">wrapper.log = log</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>This approach would work to a point, but only if it was the topmost decorator. If you had another decorator applied on top (such as the <strong>@timethis</strong> example), it would shadow the underlying attributes and make them unavailable for modification. The use of accessor functions avoids this limitation.</p>
<h2 id="Defining-a-Decorator-That-Takes-an-Optional-Argument"><a href="#Defining-a-Decorator-That-Takes-an-Optional-Argument" class="headerlink" title="Defining a Decorator That Takes an Optional Argument"></a>Defining a Decorator That Takes an Optional Argument</h2><p>You would like to write a single decorator that can be used without arguments, such as <strong>@decorator</strong>, or with optional arguments, such as <strong>@decorator(x,y,z)</strong>.</p>
<p>Here is a variant of the logging code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func= None, *, level= logging.DEBUG, name= None, message= None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> partial(logged, level= level, name= name, message= message)</span><br><span class="line"><span class="meta">... </span>    logname= name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line"><span class="meta">... </span>    log= logging.getLogger(logname)</span><br><span class="line"><span class="meta">... </span>    logmsg= message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        log.log(level, logmsg)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="meta">@logged(level=logging.CRITICAL, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure>
<p>As you can see from the example, the decorator can be used in both a simple form (i.e.,<strong>@logged</strong>) or with optional arguments supplied.</p>
<p>For a decorator taking arguments such as this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logged(level=logging.CRITICAL, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure>
<p>The calling sequence is as follows:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line">spam = logged(level=logging.CRITICAL, name=<span class="string">'example'</span>)(spam)</span><br></pre></td></tr></table></figure></p>
<p>On the initial invocation of <strong>logged()</strong>, the function to be wrapped is not passed. Thus, in the decorator, it has to be optional. This, in turn, forces the other arguments to be specified by keyword. Furthermore, when arguments are passed, a decorator is supposed to return a function that accepts the function and wraps it. To do this, the solution uses a clever trick involving <strong>functools.partial</strong>. Specifically, it simply returns a partially applied version of itself where all arguments are fixed except for the function to be wrapped. </p>
<h2 id="Enforcing-Type-Checking-on-a-Function-Using-a-Decorator"><a href="#Enforcing-Type-Checking-on-a-Function-Using-a-Decorator" class="headerlink" title="Enforcing Type Checking on a Function Using a Decorator"></a>Enforcing Type Checking on a Function Using a Decorator</h2><p>You want to optionally enforce type checking of function arguments as a kind of assertion or contract.</p>
<p>Here is an implementation of the <strong>@typeassert</strong> decorator:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(*ty_args, **ty_kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="keyword">not</span> __debug__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> func</span><br><span class="line"><span class="meta">... </span>        sig= signature(func)</span><br><span class="line"><span class="meta">... </span>        bound_types=sig.bind_partial(*ty_args, **ty_kwargs).arguments</span><br><span class="line"><span class="meta">... </span>        </span><br><span class="line"><span class="meta">... </span>        @wraps(func)</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>            bound_values= sig.bind(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> name <span class="keyword">in</span> bound_types:</span><br><span class="line"><span class="meta">... </span>                    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, bound_types[name]):</span><br><span class="line"><span class="meta">... </span>                        <span class="keyword">raise</span> TypeError(<span class="string">'Argument &#123;&#125; must be &#123;&#125;'</span>.format(name, bound_types[name]))</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> decorate</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>You will find that this decorator is rather flexible, allowing types to be specified for all or a subset of a function’s arguments. Moreover, types can be specified by position or by keyword.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@typeassert(int, z=int)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(x, y, z=<span class="number">42</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>print(x, y, z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>, <span class="string">'hello'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> hello <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>, <span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> File <span class="string">"contract.py"</span>, line <span class="number">33</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">TypeError: Argument z must be &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>In the solution, the following code fragment returns the function unmodified if the value of the global <strong>__debug__</strong> variable is set to <strong>False</strong>.</p>
<p><strong>inspect.signature()</strong> function, it allows you to extract signature information from a callable.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(x,y,z=<span class="number">42</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig= signature(spam)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sig)</span><br><span class="line">(x, y, z=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.parameters</span><br><span class="line">mappingproxy(OrderedDict([(<span class="string">'x'</span>, &lt;Parameter <span class="string">"x"</span>&gt;), (<span class="string">'y'</span>, &lt;Parameter <span class="string">"y"</span>&gt;), (<span class="string">'z'</span>, &lt;Parameter <span class="string">"z=42"</span>&gt;)]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.parameters[<span class="string">'x'</span>].name</span><br><span class="line"><span class="string">'x'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.parameters[<span class="string">'x'</span>].default</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">inspect</span>.<span class="title">_empty</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">sig</span>.<span class="title">parameters</span>['<span class="title">z</span>'].<span class="title">default</span></span></span><br><span class="line"><span class="class">42</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">sig</span>.<span class="title">parameters</span>['<span class="title">x</span>'].<span class="title">kind</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">_ParameterKind</span>.<span class="title">POSITIONAL_OR_KEYWORD</span>:</span> <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig.parameters[<span class="string">'z'</span>].kind</span><br><span class="line">&lt;_ParameterKind.POSITIONAL_OR_KEYWORD: <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>
<p>We use the <strong>bind_partial()</strong> method of signatures to perform a partial binding of the supplied types to argument names.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; bound_types= sig.bind_partial(int, z= int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types</span><br><span class="line">&lt;BoundArguments (x=&lt;class 'int'&gt;, z=&lt;class 'int'&gt;)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types.arguments</span><br><span class="line">OrderedDict([('x', &lt;class 'int'&gt;), ('z', &lt;class 'int'&gt;)])</span><br></pre></td></tr></table></figure>
<p>The most important part of the binding is the creation of the ordered dictionary <strong>bound_types.arguments</strong>. This dictionary maps the argument names to the supplied values in the same order as the function signature.</p>
<p>In the actual wrapper function made by the decorator, the <strong>sig.bind()</strong> method is used. <strong>bind()</strong> is like <strong>bind_partial()</strong> except that it does not allow for missing arguments.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_values= sig.bind(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_values.arguments</span><br><span class="line">OrderedDict([(<span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="number">3</span>)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Defining-Decorators-As-Classes"><a href="#Defining-Decorators-As-Classes" class="headerlink" title="Defining Decorators As Classes"></a>Defining Decorators As Classes</h2><p>To define a decorator as an instance, you need to make sure it implements the <strong>__call__()</strong> and <strong>__get__()</strong> methods. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Profiles</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">... </span>        wraps(func)(self)</span><br><span class="line"><span class="meta">... </span>        self.ncalls= <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.ncalls += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.__wrapped__(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> types.MethodType(self, instance)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>To use this class, you use it like a normal decorator, either inside or outside of a class:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@Profiles</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x +y</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">... </span>    @Profiles</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(self, x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.ncalls</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar(<span class="number">1</span>)</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x03D8BEF0</span>&gt; <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar(<span class="number">2</span>)</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x03D8BEF0</span>&gt; <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar.ncalls</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Spam.bar.ncalls</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>First, the use of the <strong>functools.wraps()</strong> function serves the same purpose here as it does in normal decorators—namely to copy important metadata from the wrapped function to the callable instance.</p>
<p>Second, it is common to overlook the <strong>__get__()</strong> method shown in the solution. If you omit the <strong>__get__()</strong> and keep all of the other code the same, you’ll find that bizarre things happen when you try to invoke decorated instance methods.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: spam() missing <span class="number">1</span> required positional argument: <span class="string">'x'</span></span><br></pre></td></tr></table></figure>
<p>The reason it breaks is that whenever functions implementing methods are looked up in a class, their <strong>__get__()</strong> method is invoked as part of the descriptor protocol.  In this case, the purpose of <strong>__get__()</strong> is to create a bound method object (which ultimately supplies the self argument to the method). Here is an example that illustrates the underlying mechanics:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">(self, x)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grok.__get__(s, Spam)</span><br><span class="line">&lt;bound method Spam.grok of &lt;__main__.Spam object at <span class="number">0x100671e90</span>&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>In this recipe, the <strong>__get__()</strong> method is there to make sure bound method objects get created properly. <strong>__get__()</strong>creates a bound method manually for use here. Bound methods only get created if an instance is being used. If the method is accessed on a class, the instance argument to <strong>__get__()</strong> is set to None and the Profiled instance itself is just returned.</p>
<p>If you want to avoid some of this of this mess, you might consider an alternative formulation of the decorator using closures and <strong>nonlocal</strong> variables.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">profiles</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    ncalls= <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">nonlocal</span> ncalls</span><br><span class="line"><span class="meta">... </span>        ncalls+= <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    wrapper.ncalls= <span class="keyword">lambda</span>: ncalls</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@profiles</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>This example almost works in exactly the same way except that access to <strong>ncalls</strong> is now provided through a function attached as a function attribute. For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.ncalls()</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Applying-Decorators-to-Class-and-Static-Methods"><a href="#Applying-Decorators-to-Class-and-Static-Methods" class="headerlink" title="Applying Decorators to Class and Static Methods"></a>Applying Decorators to Class and Static Methods</h2><p>Applying decorators to class and static methods is straightforward, but make sure that your decorators are applied before <strong>@classmethod</strong> or <strong>@staticmethod</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        start= time.time()</span><br><span class="line"><span class="meta">... </span>        r= func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        end= time.time()</span><br><span class="line"><span class="meta">... </span>        print(end- start)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> r</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>If you get the order of decorators wrong, you’ll get an error. For example, if you use the following:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @timethis</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method</span><span class="params">(n)</span>:</span></span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Then the static method will crash:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Spam.static_method(<span class="number">1000000</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> File <span class="string">"timethis.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> wrapper</span><br><span class="line"> start = time.time()</span><br><span class="line">TypeError: <span class="string">'staticmethod'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>One situation where this recipe is of critical importance is in defining class and static methods in abstract base classes, if you want to define an abstract class method, you can use this code:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Writing-Decorators-That-Add-Arguments-to-Wrapped-Functions"><a href="#Writing-Decorators-That-Add-Arguments-to-Wrapped-Functions" class="headerlink" title="Writing Decorators That Add Arguments to Wrapped Functions"></a>Writing Decorators That Add Arguments to Wrapped Functions</h2><p>Extra arguments can be injected into the calling signature using keyword-only arguments:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">optional_debug</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, debug= False, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> debug:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'Calling'</span>, func.__name__)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@optional_debug</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(a, b, c)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, debug= <span class="keyword">True</span>)</span><br><span class="line">Calling spam</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>One tricky part here concerns a potential name clash between the added argument and the arguments of the function being wrapped. For example, if the <strong>@optional_debug</strong> decorator was applied to a function that already had a debug argument, then it would break. If that’s a concern, an extra check could be added:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">optional_debug</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'debug'</span> <span class="keyword">in</span> inspect.getargspec(func).args:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span> TypeError(<span class="string">'debug argument already defined'</span>)</span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, debug= False, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> debug:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'Calling'</span>, func.__name__)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>A final refinement to this recipe concerns the proper management of function signatures. An astute programmer will realize that the signature of wrapped functions is wrong. For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@optional_debug</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> inspect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(add))</span><br><span class="line">(x, y)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>This can be fixed by making the following modification:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">optional_debug</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'debug'</span> <span class="keyword">in</span> inspect.getargspec(func).args:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span> TypeError(<span class="string">'debug argument already defined'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    @wraps(func)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, debug= False, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> debug:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'Calling'</span>, func.__name__)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    sig= inspect.signature(func)</span><br><span class="line"><span class="meta">... </span>    params= list(sig.parameters.values())</span><br><span class="line"><span class="meta">... </span>    params.append(inspect.Parameter(<span class="string">'debug'</span>, inspect.Parameter.KEYWORD_ONLY, default= <span class="keyword">False</span>))</span><br><span class="line"><span class="meta">... </span>    wrapper.__signature__= sig.replace(parameters= params)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>With this change, the signature of the wrapper will now correctly reflect the presence of the debug argument. For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@optional_debug</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(add))</span><br><span class="line">(x, y, *, debug=<span class="keyword">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Using-Decorators-to-Patch-Class-Definitions"><a href="#Using-Decorators-to-Patch-Class-Definitions" class="headerlink" title="Using Decorators to Patch Class Definitions"></a>Using Decorators to Patch Class Definitions</h2><p>You want to inspect or rewrite portions of a class definition to alter its behavior, but without using<br>inheritance or metaclasses.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">log_getattribute</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>    orig_attribute= cls.__getattribute__</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">new_getattribute</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'getting:'</span>, name)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> orig_attribute(self, name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    cls.__getattribute__= new_getattribute</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> cls</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@log_getattribute</span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.x= x</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=A(<span class="number">44</span>)</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __class__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __dict__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x</span><br><span class="line">getting: x</span><br><span class="line"><span class="number">44</span></span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __class__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.spam()</span><br><span class="line">getting: spam</span><br></pre></td></tr></table></figure>
<p>An alternative implementation of the solution might involve inheritance, as in the following:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">LoggedGetattribute</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'getting:'</span>, name)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> super().__getattribute__(name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(LoggedGetattribute)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.x= x</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=A(<span class="number">4</span>)</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __class__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __dict__</span><br><span class="line">getting: __dict__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.x</span><br><span class="line">getting: x</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Using-a-Metaclass-to-Control-Instance-Creation"><a href="#Using-a-Metaclass-to-Control-Instance-Creation" class="headerlink" title="Using a Metaclass to Control Instance Creation"></a>Using a Metaclass to Control Instance Creation</h2><p>You want to change the way in which instances are created in order to implement singletons, caching, or other similar features.</p>
<p>As Python programmers know, if you define a class, you call it like a function to create instances. For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">a = Spam(<span class="string">'Guido'</span>)</span><br><span class="line">b = Spam(<span class="string">'Diana'</span>)</span><br></pre></td></tr></table></figure>
<p>If you want to customize this step, you can do it by defining a metaclass and reimplementing its <strong>__call__()</strong> method in some way. </p>
<p>Now, suppose you want to implement the singleton pattern:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.__instance= <span class="keyword">None</span></span><br><span class="line"><span class="meta">... </span>        super().__init__(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="meta">... </span>            self.__instance= super().__call__(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.__instance</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.__instance</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass= Singleton)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Creating Spam'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>In this case, only one instance ever gets created. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=Spam()</span><br><span class="line">Creating Spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>Suppose you want to create cached instances:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cached</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().__init__(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        self.__cache= weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> args <span class="keyword">in</span> self.__cache:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.__cache[args]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            obj= super().__call__(*args)</span><br><span class="line"><span class="meta">... </span>            self.__cache[args]= obj</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> obj</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass= Cached)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Creating Spam(&#123;!r&#125;)'</span>.format(name))</span><br><span class="line"><span class="meta">... </span>        self.name= name</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=Spam(<span class="string">'Guido'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=Spam(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=Spam(<span class="string">'Diana'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Diana'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.cc=<span class="string">'de'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.cc</span><br><span class="line"><span class="string">'de'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Capturing-Class-Attribute-Definition-Order"><a href="#Capturing-Class-Attribute-Definition-Order" class="headerlink" title="Capturing Class Attribute Definition Order"></a>Capturing Class Attribute Definition Order</h2><p>You want to automatically record the order in which attributes and methods are defined inside a class body so that you can use it in various operations (e.g., serializing, mapping to databases, etc.).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Typed</span>:</span></span><br><span class="line"><span class="meta">... </span>    _expected_type= type(<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name= None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._name= name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, self._expected_type):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError(<span class="string">'Expected '</span>+ str(self._expected_type))</span><br><span class="line"><span class="meta">... </span>        instance.__dict__[self._name]= value</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Integer</span><span class="params">(Typed)</span>:</span> _expected_type = int</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Float</span><span class="params">(Typed)</span>:</span> _expected_type = float</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">String</span><span class="params">(Typed)</span>:</span> _expected_type = str</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">OrderedMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'cls:&#123;&#125;\nclsname: &#123;&#125;\nbases: &#123;&#125;\nclsdict: &#123;&#125;'</span>.format(cls, clsname,bases,clsdict))</span><br><span class="line"><span class="meta">... </span>        d= dict(clsdict)</span><br><span class="line"><span class="meta">... </span>        order=[]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> name, value <span class="keyword">in</span> clsdict.items():</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> isinstance(value, Typed):</span><br><span class="line"><span class="meta">... </span>                value._name= name</span><br><span class="line"><span class="meta">... </span>                order.append(name)</span><br><span class="line"><span class="meta">... </span>        d[<span class="string">'_order'</span>] = order</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> type.__new__(cls, clsname, bases, d)</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, clsname, bases)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> OrderedDict()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>In this metaclass, the definition order of descriptors is captured by using an <strong>OrderedDict</strong> during the execution of the class body. The resulting order of names is then extracted from the dictionary and stored into a class attribute <strong>_order</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Structure</span><span class="params">(metaclass= OrderedMeta)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">as_csv</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">','</span>.join(str(getattr(self, name)) <span class="keyword">for</span> name <span class="keyword">in</span> self._order)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">cls:&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">OrderedMeta</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">clsname</span>:</span> Structure</span><br><span class="line">bases: ()</span><br><span class="line">clsdict: OrderedDict([(<span class="string">'__module__'</span>, <span class="string">'__main__'</span>), (<span class="string">'__qualname__'</span>, <span class="string">'Structure'</span>), (<span class="string">'as_csv'</span>, &lt;function Structure.as_csv at <span class="number">0x0399F108</span>&gt;)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure)</span>:</span></span><br><span class="line"><span class="meta">... </span>    name= String()</span><br><span class="line"><span class="meta">... </span>    shares=Integer()</span><br><span class="line"><span class="meta">... </span>    price= Float()</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name= name</span><br><span class="line"><span class="meta">... </span>        self.shares= shares</span><br><span class="line"><span class="meta">... </span>        self.price= price</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">cls:&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">OrderedMeta</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">clsname</span>:</span> Stock</span><br><span class="line">bases: (&lt;class '__main__.Structure'&gt;,)</span><br><span class="line">clsdict: OrderedDict([(<span class="string">'__module__'</span>, <span class="string">'__main__'</span>), (<span class="string">'__qualname__'</span>, <span class="string">'Stock'</span>), (<span class="string">'name'</span>, &lt;__main__.String object at <span class="number">0x039A4370</span>&gt;), (<span class="string">'shares'</span>, &lt;__main__.Integer object at <span class="number">0x039A46B0</span>&gt;), (<span class="string">'price'</span>, &lt;__main__.Float object at <span class="number">0x039A47B0</span>&gt;), (<span class="string">'__init__'</span>, &lt;function Stock.__init__ at <span class="number">0x0399F660</span>&gt;)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s= Stock(<span class="string">'ff'</span>,<span class="number">12</span>,<span class="number">3.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">'ff'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.as_csv()</span><br><span class="line"><span class="string">'ff,12,3.5'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t= Stock(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3.5</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">6</span>, <span class="keyword">in</span> __init__</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">7</span>, <span class="keyword">in</span> __set__</span><br><span class="line">TypeError: Expected &lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>The entire key to this recipe is the <strong>__prepare__()</strong> method, which is defined in the <strong>OrderedMeta</strong> metaclass. This method is invoked immediately at the start of a class definition with the class name and base classes. It must then return a mapping object to use when processing the class body. By returning an <strong>OrderedDict</strong> instead of a normal dictionary, the resulting definition order is easily captured.</p>
<p>It is possible to extend this functionality even further if you are willing to make your own dictionary-like objects. For example, consider this variant of the solution that rejects duplicate definitions:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">NoDupOrderedDict</span><span class="params">(OrderedDict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, clsname)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.clsname= clsname</span><br><span class="line"><span class="meta">... </span>        super().__init__()</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> name <span class="keyword">in</span> self:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; already defined in &#123;&#125;'</span>.format(name, self.clsname))</span><br><span class="line"><span class="meta">... </span>        super().__setitem__(name, value)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">OrderedMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line"><span class="meta">... </span>        d= dict(clsdict)</span><br><span class="line"><span class="meta">... </span>        d[<span class="string">'_order'</span>]= [name <span class="keyword">for</span> name <span class="keyword">in</span> clsdict <span class="keyword">if</span> name[<span class="number">0</span>]!= <span class="string">'_'</span>]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> type.__new__(cls, clsname, bases, d)</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, clsname, bases)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> NoDupOrderedDict(clsname)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Here’s what happens if you use this metaclass and make a class with duplicate entries:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass= OrderedMeta)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> A</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">7</span>, <span class="keyword">in</span> __setitem__</span><br><span class="line">TypeError: spam already defined <span class="keyword">in</span> A</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Defining-a-Metaclass-That-Takes-Optional-Arguments"><a href="#Defining-a-Metaclass-That-Takes-Optional-Arguments" class="headerlink" title="Defining a Metaclass That Takes Optional Arguments"></a>Defining a Metaclass That Takes Optional Arguments</h2><p>In custom metaclasses, additional keyword arguments can be supplied, like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=MyMeta, debug=True, synchronize=True)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>To support such keyword arguments in a metaclass, make sure you define them on the <strong>__prepare__()</strong>, <strong>__new__()</strong>, and <strong>__init__()</strong> methods using keyword-only arguments, like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># Optional</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">return</span> super().__prepare__(name, bases)</span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, ns, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, ns)</span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, ns, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        ...</span><br><span class="line">        super().__init__(name, bases, ns)</span><br></pre></td></tr></table></figure>
<p>The <strong>__prepare__()</strong> method is called first and used to create the class namespace prior to the body of any class definition being processed. Normally, this method simply returns a dictionary or other mapping object. The <strong>__new__()</strong> method is used to instantiate the resulting type object. It is called after the class body has been fully executed. The <strong>__init__()</strong> method is called last and used to perform any additional initialization steps.</p>
<p>When writing metaclasses, it is somewhat common to only define a <strong>__new__()</strong> or <strong>__init__()</strong> method, but not both. However, if extra keyword arguments are going to be accepted, then both methods must be provided and given compatible signatures. The default <strong>__prepare__()</strong> method accepts any set of keyword arguments, but ignores them. You only need to define it yourself if the extra arguments would somehow affect management of the class namespace creation.</p>
<h2 id="Enforcing-an-Argument-Signature-on-args-and-kwargs"><a href="#Enforcing-an-Argument-Signature-on-args-and-kwargs" class="headerlink" title="Enforcing an Argument Signature on *args and **kwargs"></a>Enforcing an Argument Signature on *args and **kwargs</h2><p>You’ve written a function or method that uses <strong>*args</strong> and <strong>**kwargs</strong>, so that it can be general purpose, but you would also like to check the passed arguments to see if they match a specific function calling signature. Two classes, <strong>Signature</strong> and <strong>Parameter</strong>, are of particular interest here. Here is an interactive example of creating a function signature:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>params=[Parameter(<span class="string">'x'</span>, Parameter.POSITIONAL_OR_KEYWORD),</span><br><span class="line"><span class="meta">... </span>        Parameter(<span class="string">'y'</span>, Parameter.POSITIONAL_OR_KEYWORD, default= <span class="number">2</span>),</span><br><span class="line"><span class="meta">... </span>        Parameter(<span class="string">'z'</span>, Parameter.KEYWORD_ONLY, default= <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span>        ]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig= Signature(params)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sig)</span><br><span class="line">(x, y=<span class="number">2</span>, *, z=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>Once you have a signature object, you can easily bind it to <strong>*args</strong> and <strong>**kwargs</strong> using the signature’s <strong>bind()</strong> method.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    bound_values= sig.bind(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>        print(name, value)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(y=<span class="number">2</span>, x=<span class="number">1</span>)</span><br><span class="line">x <span class="number">1</span></span><br><span class="line">y <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line"> File <span class="string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="number">1972</span>, <span class="keyword">in</span> _bind</span><br><span class="line"> <span class="keyword">raise</span> TypeError(<span class="string">'too many positional arguments'</span>)</span><br><span class="line">TypeError: too many positional arguments</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(y=<span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line"> File <span class="string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="number">1961</span>, <span class="keyword">in</span> _bind</span><br><span class="line"> <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="keyword">None</span></span><br><span class="line">TypeError: <span class="string">'x'</span> parameter lacking default value</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, y=<span class="number">2</span>, x=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line"> File <span class="string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="number">1985</span>, <span class="keyword">in</span> _bind</span><br><span class="line"> <span class="string">'&#123;arg!r&#125;'</span>.format(arg=param.name))</span><br><span class="line">TypeError: multiple values <span class="keyword">for</span> argument <span class="string">'x'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>Here is a more concrete example of enforcing function signatures. In this code, a base class has defined an extremely general-purpose version of <strong>__init__()</strong>, but subclasses are expected to supply an expected signature.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_sig</span><span class="params">(*names)</span>:</span></span><br><span class="line"><span class="meta">... </span>    params=[Parameter(name, Parameter.POSITIONAL_OR_KEYWORD) <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> Signature(parameters=params)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Structure</span>:</span></span><br><span class="line"><span class="meta">... </span>    __signature__= make_sig()</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        bound_values= self.__signature__.bind(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>            setattr(self, name, value)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure)</span>:</span></span><br><span class="line"><span class="meta">... </span>    __signature__= make_sig(<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure)</span>:</span></span><br><span class="line"><span class="meta">... </span>    __signature__= make_sig(<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> inspect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(Stock))</span><br><span class="line">(name, shares, price)</span><br></pre></td></tr></table></figure>
<p>The use of functions involving <strong>*args</strong> and <strong>**kwargs</strong> is very common when trying to make general-purpose libraries, write decorators or implement proxies. However, one downside of such functions is that if you want to implement your own argument checking, it can quickly become an unwieldy mess.</p>
<p>In the last example of the solution, it might make sense to create signature objects through the use of a custom metaclass.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">StructureMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line"><span class="meta">... </span>        clsdict[<span class="string">'__signature__'</span>]= make_sig(*clsdict.get(<span class="string">'_fields'</span>, []))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> super().__new__(cls, clsname, bases, clsdict)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Structure</span><span class="params">(metaclass= StructureMeta)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _fields=[]</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        bound_values= self.__signature__.bind(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>            setattr(self, name, value)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _fields=[<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _fields= [<span class="string">'x'</span>, <span class="string">'y'</span>]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inspect.signature(Stock)</span><br><span class="line">&lt;Signature (name, shares, price)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(Point))</span><br><span class="line">(x, y)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>When defining custom signatures, it is often useful to store the signature in a special attribute <strong>__signature__</strong>, as shown. If you do this, code that uses the inspect module to perform introspection will see the signature and report it as the calling convention.</p>
<h2 id="Enforcing-Coding-Conventions-in-Classes"><a href="#Enforcing-Coding-Conventions-in-Classes" class="headerlink" title="Enforcing Coding Conventions in Classes"></a>Enforcing Coding Conventions in Classes</h2><p>A key feature of a metaclass is that it allows you to examine the contents of a class at the time of definition. Inside the redefined <strong>__init__()</strong> method, you are free to inspect the class dictionary, base classes, and more. Moreover, once a metaclass has been specified for a class, it gets inherited by all of the subclasses. Thus, a sneaky framework builder can specify a metaclass for one of the top-level classes in a large hierarchy and capture the definition of all classes under it.</p>
<p>Here is a metaclass that rejects any class definition containing methods with mixed-case names:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">NoMixedCaseMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(clsdict)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> name <span class="keyword">in</span> clsdict:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> name.lower() != name:</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">raise</span> TypeError(<span class="string">'Bad attribute name: '</span>+name)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> super().__new__(cls, clsname, bases, clsdict)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(metaclass= NoMixedCaseMeta)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&#123;<span class="string">'__qualname__'</span>: <span class="string">'Root'</span>, <span class="string">'__module__'</span>: <span class="string">'__main__'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">fooBar</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&#123;<span class="string">'__qualname__'</span>: <span class="string">'B'</span>, <span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'fooBar'</span>: &lt;function B.fooBar at <span class="number">0x0399FF60</span>&gt;&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">6</span>, <span class="keyword">in</span> __new__</span><br><span class="line">TypeError: Bad attribute name: fooBar</span><br></pre></td></tr></table></figure>
<p>As a more advanced and useful example, here is a metaclass that checks the definition of redefined methods to make sure they have the same calling signature as the original method in the superclass.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> logging</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MatchSignaturesMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, clsname, bases, clsdict)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().__init__(clsname, bases, clsdict)</span><br><span class="line"><span class="meta">... </span>        sup=super(self, self)</span><br><span class="line"><span class="meta">... </span>        print(clsdict.items())</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> name, value <span class="keyword">in</span> clsdict.items():</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>) <span class="keyword">or</span> <span class="keyword">not</span> callable(value):</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">continue</span></span><br><span class="line"><span class="meta">... </span>            prev_dfn= getattr(sup, name, <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> prev_dfn:</span><br><span class="line"><span class="meta">... </span>                prev_sig= signature(prev_dfn)</span><br><span class="line"><span class="meta">... </span>                val_sig= signature(value)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> prev_sig != val_sig:</span><br><span class="line"><span class="meta">... </span>                    logging.warning(<span class="string">'Signature mismatch in %s. %s != %s'</span>, value.__qualname__, prev_sig, val_sig)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(metaclass= MatchSignaturesMeta)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dict_items([(<span class="string">'__qualname__'</span>, <span class="string">'Root'</span>), (<span class="string">'__module__'</span>, <span class="string">'__main__'</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Root)</span>:</span> </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, x, y)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x, *, z)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dict_items([(<span class="string">'foo'</span>, &lt;function A.foo at <span class="number">0x039A8270</span>&gt;), (<span class="string">'spam'</span>, &lt;function A.spam at <span class="number">0x039A8228</span>&gt;), (<span class="string">'__qualname__'</span>, <span class="string">'A'</span>), (<span class="string">'__module__'</span>, <span class="string">'__main__'</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super(A, A)</span><br><span class="line">&lt;super: &lt;class 'A'&gt;, &lt;A object&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, a, b)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self,x, z)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dict_items([(<span class="string">'foo'</span>, &lt;function B.foo at <span class="number">0x039A88E8</span>&gt;), (<span class="string">'spam'</span>, &lt;function B.spam at <span class="number">0x039A88A0</span>&gt;), (<span class="string">'__qualname__'</span>, <span class="string">'B'</span>), (<span class="string">'__module__'</span>, <span class="string">'__main__'</span>)])</span><br><span class="line">WARNING:root:Signature mismatch <span class="keyword">in</span> B.foo. (self, x, y) != (self, a, b)</span><br><span class="line">WARNING:root:Signature mismatch <span class="keyword">in</span> B.spam. (self, x, *, z) != (self, x, z)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>As a more advanced and useful example, here is a metaclass that checks the definition of redefined methods to make sure they have the same calling signature as the original method in the superclass.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MatchSignaturesMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, clsname, bases, clsdict)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().__init__(clsname, bases, clsdict)</span><br><span class="line"><span class="meta">... </span>        sup=super(self, self)</span><br><span class="line"><span class="meta">... </span>        print(clsdict.items())</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> name, value <span class="keyword">in</span> clsdict.items():</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>) <span class="keyword">or</span> <span class="keyword">not</span> callable(value):</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">continue</span></span><br><span class="line"><span class="meta">... </span>            prev_dfn= getattr(sup, name, <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> prev_dfn:</span><br><span class="line"><span class="meta">... </span>                prev_sig= signature(prev_dfn)</span><br><span class="line"><span class="meta">... </span>                val_sig= signature(value)</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">if</span> prev_sig != val_sig:</span><br><span class="line"><span class="meta">... </span>                    logging.warning(<span class="string">'Signature mismatch in %s. %s != %s'</span>, value.__qualname__, prev_sig, val_sig)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(metaclass= MatchSignaturesMeta)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dict_items([(<span class="string">'__qualname__'</span>, <span class="string">'Root'</span>), (<span class="string">'__module__'</span>, <span class="string">'__main__'</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Root)</span>:</span> </span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, x, y)</span>:</span><span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x, *, z)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dict_items([(<span class="string">'foo'</span>, &lt;function A.foo at <span class="number">0x039A8270</span>&gt;), (<span class="string">'spam'</span>, &lt;function A.spam at <span class="number">0x039A8228</span>&gt;), (<span class="string">'__qualname__'</span>, <span class="string">'A'</span>), (<span class="string">'__module__'</span>, <span class="string">'__main__'</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super(A, A)</span><br><span class="line">&lt;super: &lt;class 'A'&gt;, &lt;A object&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self, a, b)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self,x, z)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">dict_items([(<span class="string">'foo'</span>, &lt;function B.foo at <span class="number">0x039A88E8</span>&gt;), (<span class="string">'spam'</span>, &lt;function B.spam at <span class="number">0x039A88A0</span>&gt;), (<span class="string">'__qualname__'</span>, <span class="string">'B'</span>), (<span class="string">'__module__'</span>, <span class="string">'__main__'</span>)])</span><br><span class="line">WARNING:root:Signature mismatch <span class="keyword">in</span> B.foo. (self, x, y) != (self, a, b)</span><br><span class="line">WARNING:root:Signature mismatch <span class="keyword">in</span> B.spam. (self, x, *, z) != (self, x, z)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>The choice of redefining <strong>__new__()</strong> or <strong>__init__()</strong> in a metaclass depends on how you want to work with the resulting class. <strong>__new__()</strong> is invoked prior to class creation and is typically used when a metaclass wants to alter the class definition in some way (by changing the contents of the class dictionary). The <strong>__init__()</strong> method is invoked after a class has been created, and is useful if you want to write code that works with the fully formed class object. In the last example, this is essential since it is using the super() function to search for prior definitions. This only works once the class instance has been created and the underlying method resolution order has been set.</p>
<p>The line of code that uses <strong>super(self, self)</strong> is not a typo. When working with a metaclass, it’s important to realize that the <strong>self</strong> is actually a class object. So, that statement is actually being used to find definitions located further up the class hierarchy that make up the parents of <strong>self</strong>.</p>
<h2 id="Defining-Classes-Programmatically"><a href="#Defining-Classes-Programmatically" class="headerlink" title="Defining Classes Programmatically"></a>Defining Classes Programmatically</h2><p>You can use the function <strong>types.new_class()</strong> to instantiate new class objects. All you need to do is provide the name of the class, tuple of parent classes, keyword arguments, and a callback that populates the class dictionary with members.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line"><span class="meta">... </span>    self.name= name</span><br><span class="line"><span class="meta">... </span>    self.shares= shares</span><br><span class="line"><span class="meta">... </span>    self.price= price</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> self.shares * self.price</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cls_dict=&#123; <span class="string">'__init__'</span>: __init__,</span><br><span class="line"><span class="meta">... </span>          <span class="string">'cost'</span>: cost&#125;</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock= types.new_class(<span class="string">'Stock'</span>, (), &#123;&#125;, <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock.__module__= __name__</span><br></pre></td></tr></table></figure>
<p>This makes a normal class object that works just like you expect:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s= Stock(<span class="string">'Acme'</span>, <span class="number">10</span>, <span class="number">4.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Stock object at <span class="number">0x0399CE70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.cost()</span><br><span class="line"><span class="number">44.0</span></span><br></pre></td></tr></table></figure>
<p>A subtle facet of the solution is the assignment to <strong>Stock.__module__</strong> after the call to <strong>types.new_class()</strong>. Whenever a class is defined, its <strong>__module__</strong> attribute contains the name of the module in which it was defined. This name is used to produce the output made by methods such as <strong>__repr__()</strong>. It’s also used by various libraries, such as <strong>pickle</strong>. Thus, in order for the class you make to be “proper,” you need to make sure this attribute is set accordingly.</p>
<p>If the class you want to create involves a different metaclass, it would be specified in the third argument to <strong>types.new_class()</strong>. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock= types.new_class(<span class="string">'Stock'</span>, (), &#123;<span class="string">'metaclass'</span>: abc.ABCMeta&#125;, <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock.__module__= __name__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Stock</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(Stock)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">abc</span>.<span class="title">ABCMeta</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>The fourth argument to <strong>new_class()</strong> is the most mysterious, but it is a function that receives the mapping object being used for the class namespace as input. This is normally a dictionary, but it’s actually whatever object gets returned by the <strong>__prepare__()</strong> method.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">named_tuple</span><span class="params">(classname, fieldnames)</span>:</span></span><br><span class="line"><span class="meta">... </span>    cls_dict= &#123;name: property(operator.itemgetter(n)) <span class="keyword">for</span> n, name <span class="keyword">in</span> enumerate(fieldnames)&#125;</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> len(args) != len(fieldnames):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError(<span class="string">'Expected &#123;&#125; arguments'</span>.format(len(fieldnames)))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> tuple.__new__(cls, args)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    cls_dict[<span class="string">'__new__'</span>]= __new__</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    cls= types.new_class(classname, (tuple,),&#123;&#125;,<span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    cls.__module__= sys._getframe(<span class="number">1</span>).f_globals[<span class="string">'__name__'</span>]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> cls</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The last part of this code uses a so-called “frame hack” involving <strong>sys._getframe()</strong> to obtain the module name of the caller.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point= named_tuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Point</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; p= Point(4,5)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(p)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x= <span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(p)</span></span><br><span class="line"><span class="string">(4, 5)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; Point(2,3,4)</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 6, in __new__</span></span><br><span class="line"><span class="string">TypeError: Expected 2 arguments</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>You might be inclined to create a class directly by instantiating a metaclass directly. For example:</p>
<p><code>Stock = type(&#39;Stock&#39;, (), cls_dict)</code></p>
<p>The problem is that this approach skips certain critical steps, such as invocation of the metaclass <strong>__prepare__()</strong> method. By using types.new_class() instead, you ensure that all of the necessary initialization steps get carried out. For instance, the callback function that’s given as the fourth argument to <strong>types.new_class()</strong> receives the mapping object that’s returned by the <strong>__prepare__()</strong> method.</p>
<p>If you only want to carry out the preparation step, use <strong>types.prepare_class()</strong>. For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line">metaclass, kwargs, ns = types.prepare_class(<span class="string">'Stock'</span>, (), &#123;<span class="string">'metaclass'</span>: type&#125;)</span><br></pre></td></tr></table></figure>
<p>This finds the appropriate metaclass and invokes its <strong>__prepare__()</strong> method. The metaclass, remaining keyword arguments, and prepared namespace are then returned.</p>
<h2 id="Initializing-Class-Members-at-Definition-Time"><a href="#Initializing-Class-Members-at-Definition-Time" class="headerlink" title="Initializing Class Members at Definition Time"></a>Initializing Class Members at Definition Time</h2><p>Performing initialization or setup actions at the time of class definition is a classic use of metaclasses. Essentially, a metaclass is triggered at the point of a definition, at which point you can perform additional steps.</p>
<p>Here is an example that uses this idea to create classes similar to named tuples from the <strong>collections</strong> module:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">StructTupleMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().__init__(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> n, name <span class="keyword">in</span> enumerate(cls._fields):</span><br><span class="line"><span class="meta">... </span>            setattr(cls, name, property(operator.itemgetter(n)))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">StructTuple</span><span class="params">(tuple, metaclass= StructTupleMeta)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _fields= []</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> len(args) != len(cls._fields):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">'&#123;&#125; arguments required'</span>.format(len(cls._fields)))</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> super().__new__(cls, args)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(StructTuple)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _fields= [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(StructTuple)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _fields= [<span class="string">'x'</span>, <span class="string">'y'</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Here’s how they work:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shares * s.price</span><br><span class="line"><span class="number">4555.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shares = <span class="number">23</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>In this recipe, the <strong>StructTupleMeta</strong> class takes the listing of attribute names in the <strong>_fields</strong> class attribute and turns them into property methods that access a particular tuple slot. The <strong>operator.itemgetter()</strong> function creates an accessor function and the <strong>property()</strong> function turns it into a property.</p>
<p>The trickiest part of this recipe is knowing when the different initialization steps occur. The <strong>__init__()</strong> method in <strong>StructTupleMeta</strong> is only called once for each class that is defined. The <strong>cls</strong> argument is the class that has just been defined. Essentially, the code is using the <strong>_fields</strong> class variable to take the newly defined class and add some new parts to it.</p>
<p>The <strong>StructTuple</strong> class serves as a common base class for users to inherit from. The <strong>__new__()</strong> method in that class is responsible for making new instances. The use of <strong>__new__()</strong> here is a bit unusual, but is partly related to the fact that we’re modifying the calling signature of tuples so that we can create instances with code that uses a normal looking calling convention like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>) <span class="comment"># OK</span></span><br><span class="line">s = Stock((<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)) <span class="comment"># Error</span></span><br></pre></td></tr></table></figure>
<p>Unlike <strong>__init__()</strong>, the <strong>__new__()</strong> method gets triggered before an instance is created. Since tuples are immutable, it’s not possible to make any changes to them once they have been created. An <strong><strong>init</strong>()</strong> function gets triggered too late in the instance creation process to do what we want. That’s why <strong>__new__()</strong> has been defined.</p>
<h2 id="Implementing-Multiple-Dispatch-with-Function-Annotations"><a href="#Implementing-Multiple-Dispatch-with-Function-Annotations" class="headerlink" title="Implementing Multiple Dispatch with Function Annotations"></a>Implementing Multiple Dispatch with Function Annotations</h2><p>You’ve learned about function argument annotations and you have a thought that you might be able to use them to implement multiple-dispatch (method overloading) based on types.</p>
<p>Here is the start of a solution that does just that, using a combination of metaclasses and descriptors:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiMethod</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Represents a single multimethod.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._methods = &#123;&#125;</span><br><span class="line">        self.__name__ = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, meth)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Register a new method as a multimethod</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        sig = inspect.signature(meth)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Build a type-signature from the method's annotations</span></span><br><span class="line">        types = []</span><br><span class="line">        <span class="keyword">for</span> name, parm <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">'self'</span>: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> parm.annotation <span class="keyword">is</span> inspect.Parameter.empty:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(</span><br><span class="line">                    <span class="string">'Argument &#123;&#125; must be annotated with a type'</span>.format(name)</span><br><span class="line">                    )</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(parm.annotation, type):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(</span><br><span class="line">                    <span class="string">'Argument &#123;&#125; annotation must be a type'</span>.format(name)</span><br><span class="line">                    )</span><br><span class="line">            <span class="keyword">if</span> parm.default <span class="keyword">is</span> <span class="keyword">not</span> inspect.Parameter.empty:</span><br><span class="line">                self._methods[tuple(types)] = meth</span><br><span class="line">            types.append(parm.annotation)</span><br><span class="line"></span><br><span class="line">        self._methods[tuple(types)] = meth</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Call a method based on type signature of the arguments</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        types = tuple(type(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args[<span class="number">1</span>:])</span><br><span class="line">        meth = self._methods.get(types, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> meth:</span><br><span class="line">            <span class="keyword">return</span> meth(*args)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'No matching method for types &#123;&#125;'</span>.format(types))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Descriptor method needed to make calls work in a class</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> types.MethodType(self, instance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Special dictionary to build multimethods in a metaclass</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="comment"># If key already exists, it must be a multimethod or callable</span></span><br><span class="line">            current_value = self[key]</span><br><span class="line">            <span class="keyword">if</span> isinstance(current_value, MultiMethod):</span><br><span class="line">                current_value.register(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mvalue = MultiMethod(key)</span><br><span class="line">                mvalue.register(current_value)</span><br><span class="line">                mvalue.register(value)</span><br><span class="line">                super().__setitem__(key, mvalue)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultipleMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Metaclass that allows multiple dispatch of methods</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, clsdict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, dict(clsdict))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, clsname, bases)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MultiDict()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Some example classes that use multiple dispatch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=MultipleMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x:int, y:int)</span>:</span></span><br><span class="line">        print(<span class="string">'Bar 1:'</span>, x, y)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, s:str, n:int = <span class="number">0</span>)</span>:</span></span><br><span class="line">        print(<span class="string">'Bar 2:'</span>, s, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example: overloaded __init__</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(metaclass=MultipleMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year: int, month:int, day:int)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        t = time.localtime()</span><br><span class="line">        self.__init__(t.tm_year, t.tm_mon, t.tm_mday)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Spam()</span><br><span class="line">    s.bar(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    s.bar(<span class="string">'hello'</span>)</span><br><span class="line">    s.bar(<span class="string">'hello'</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.bar(<span class="number">2</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Overloaded __init__</span></span><br><span class="line">    d = Date(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line">    print(d.year, d.month, d.day)</span><br><span class="line">    <span class="comment"># Get today's date</span></span><br><span class="line">    e = Date()</span><br><span class="line">print(e.year, e.month, e.day)</span><br></pre></td></tr></table></figure>
<p>The main idea in the implementation is relatively simple. The <strong>MutipleMeta</strong> metaclass uses its <strong>__prepare__()</strong> method to supply a custom class dictionary as an instance of <strong>MultiDict</strong>. Unlike a normal dictionary, <strong>MultiDict</strong> checks to see whether entries already exist when items are set. If so, the duplicate entries get merged together inside an instance of MultiMethod.</p>
<p>Instances of <strong>MultiMethod</strong> collect methods by building a mapping from type signatures to functions. During construction, function annotations are used to collect these signatures and build the mapping. This takes place in the <strong>MultiMethod.register()</strong> method. One critical part of this mapping is that for multimethods, types must be specified on all of the arguments or else an error occurs.</p>
<p>To make <strong>MultiMethod</strong> instances emulate a callable, the <strong>__call__()</strong> method is implemented. This method builds a type tuple from all of the arguments except self, looks up the method in the internal map, and invokes the appropriate method. The <strong>__get__()</strong> is required to make <strong>MultiMethod</strong> instances operate correctly inside class definitions. In the implementation, it’s being used to create proper bound methods. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = s.bar</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&lt;bound method Spam.bar of &lt;__main__.Spam object at <span class="number">0x1006a46d0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__self__</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x1006a46d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__func__</span><br><span class="line">&lt;__main__.MultiMethod object at <span class="number">0x1006a4d50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Bar <span class="number">1</span>: <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(<span class="string">'hello'</span>)</span><br><span class="line">Bar <span class="number">2</span>: hello <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>As an alternative to using metaclasses and annotations, it is possible to implement a similar recipe using decorators. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multimethod</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._methods = &#123;&#125;</span><br><span class="line">        self.__name__ = func.__name__</span><br><span class="line">        self._default = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, *types)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">            ndefaults = len(func.__defaults__) <span class="keyword">if</span> func.__defaults__ <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(ndefaults+<span class="number">1</span>):</span><br><span class="line">                self._methods[types[:len(types) - n]] = func</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> register</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        types = tuple(type(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args[<span class="number">1</span>:])</span><br><span class="line">        meth = self._methods.get(types, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> meth:</span><br><span class="line">            <span class="keyword">return</span> meth(*args)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._default(*args)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> types.MethodType(self, instance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">    @multimethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="comment"># Default method called if no match</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'No matching method for bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @bar.match(int, int)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        print(<span class="string">'Bar 1:'</span>, x, y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @bar.match(str, int)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, s, n = <span class="number">0</span>)</span>:</span></span><br><span class="line">        print(<span class="string">'Bar 2:'</span>, s, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Spam()</span><br><span class="line">    s.bar(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    s.bar(<span class="string">'hello'</span>)</span><br><span class="line">    s.bar(<span class="string">'hello'</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.bar(<span class="number">2</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>
<h2 id="Avoiding-Repetitive-Property-Methods"><a href="#Avoiding-Repetitive-Property-Methods" class="headerlink" title="Avoiding Repetitive Property Methods"></a>Avoiding Repetitive Property Methods</h2><p>You are writing classes where you are repeatedly having to define property methods that perform common tasks, such as type checking. You would like to simplify the code so there is not so much code repetition.</p>
<p>One possible approach is to make a function that simply defines the property for you and returns it. For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">typed_property</span><span class="params">(name, expected_type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    storage_name= <span class="string">'_'</span>+ name</span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> getattr(self, storage_name)</span><br><span class="line"><span class="meta">... </span>    @prop.setter</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self, value)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, expected_type):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; must be a &#123;&#125;'</span>.format(name, expected_type))</span><br><span class="line"><span class="meta">... </span>        setattr(self, storage_name, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> prop</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">... </span>    name = typed_property(<span class="string">'name'</span>, str)</span><br><span class="line"><span class="meta">... </span>    age= typed_property(<span class="string">'age'</span>, int)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name= name</span><br><span class="line"><span class="meta">... </span>        self.age= age</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>The <strong>typed_property()</strong> function in this example may look a little weird, but it’s really just generating the property code for you and returning the resulting property object. Thus, when it’s used in a class, it operates exactly as if the code appearing inside <strong>typed_property()</strong> was placed into the class definition itself. Even though the property getter and setter methods are accessing local variables such as <strong>name</strong>, <strong>expected_type</strong>, and <strong>storage_name</strong>, that is fine—those values are held behind the scenes in a closure.</p>
<p>This recipe can be tweaked in an interesting manner using the <strong>functools.partial()</strong> function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">String = partial(typed_property, expected_type=str)</span><br><span class="line">Integer = partial(typed_property, expected_type=int)</span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = String(<span class="string">'name'</span>)</span><br><span class="line">    age = Integer(<span class="string">'age'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>
<h2 id="Defining-Context-Managers-the-Easy-Way"><a href="#Defining-Context-Managers-the-Easy-Way" class="headerlink" title="Defining Context Managers the Easy Way"></a>Defining Context Managers the Easy Way</h2><p>One of the most straightforward ways to write a new context manager is to use the <strong>@contextmanager</strong> decorator in the <strong>contextlib</strong> module.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@contextmanager</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">timtethis</span><span class="params">(label)</span>:</span></span><br><span class="line"><span class="meta">... </span>    start= time.time()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>        end=time.time()</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(label, end- start))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> timtethis(<span class="string">'counting'</span>):</span><br><span class="line"><span class="meta">... </span>    n= <span class="number">100000</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        n -= <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">counting: <span class="number">0.014844417572021484</span></span><br></pre></td></tr></table></figure>
<p>In the <strong>timethis()</strong> function, all of the code prior to the yield executes as the <strong>__enter__()</strong> method of a context manager. All of the code after the yield executes as the <strong>__exit__()</strong> method. If there was an exception, it is raised at the <strong>yield</strong> statement.</p>
<p>Here is a slightly more advanced context manager that implements a kind of transaction on a list object:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@contextmanager</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">list_transaction</span><span class="params">(orig_list)</span>:</span></span><br><span class="line"><span class="meta">... </span>    working= list(orig_list)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> working</span><br><span class="line"><span class="meta">... </span>    orig_list[:]= working</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> list_transaction(items) <span class="keyword">as</span> working:</span><br><span class="line"><span class="meta">... </span>    working.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">... </span>    working.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>Normally, to write a context manager, you define a class with an <strong>__enter__()</strong> and <strong>__exit__()</strong> method:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timethis</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, label)</span>:</span></span><br><span class="line">        self.label = label</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start = time.time()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_ty, exc_val, exc_tb)</span>:</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(self.label, end - self.start))</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/15/C08-Classes-and-Objects/" rel="next" title="C08_Classes_and_Objects">
                <i class="fa fa-chevron-left"></i> C08_Classes_and_Objects
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/15/C11-Network-and-Web-Programming/" rel="prev" title="C11_Network_and_Web_Programming">
                C11_Network_and_Web_Programming <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="eustoma" />
            
              <p class="site-author-name" itemprop="name">eustoma</p>
              <p class="site-description motion-element" itemprop="description">Too young to be old, too old to be young</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/bobingski" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://t.me/naeJean" target="_blank" title="Telegram">
                      
                        <i class="fa fa-fw fa-telegram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://newdoub.com" title="doubi1" target="_blank">doubi1</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://doub.io" title="doubi2" target="_blank">doubi2</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://google1.jiongjun.cc/" title="mirror" target="_blank">mirror</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://program-think.blogspot.com/" title="blogspot" target="_blank">blogspot</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Putting-a-Wrapper-Around-a-Function"><span class="nav-number">1.</span> <span class="nav-text">Putting a Wrapper Around a Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Preserving-Function-Metadata-When-Writing-Decorators"><span class="nav-number">2.</span> <span class="nav-text">Preserving Function Metadata When Writing Decorators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unwrapping-a-Decorator"><span class="nav-number">3.</span> <span class="nav-text">Unwrapping a Decorator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-a-Decorator-That-Takes-Arguments"><span class="nav-number">4.</span> <span class="nav-text">Defining a Decorator That Takes Arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-a-Decorator-with-User-Adjustable-Attributes"><span class="nav-number">5.</span> <span class="nav-text">Defining a Decorator with User Adjustable Attributes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-a-Decorator-That-Takes-an-Optional-Argument"><span class="nav-number">6.</span> <span class="nav-text">Defining a Decorator That Takes an Optional Argument</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enforcing-Type-Checking-on-a-Function-Using-a-Decorator"><span class="nav-number">7.</span> <span class="nav-text">Enforcing Type Checking on a Function Using a Decorator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-Decorators-As-Classes"><span class="nav-number">8.</span> <span class="nav-text">Defining Decorators As Classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applying-Decorators-to-Class-and-Static-Methods"><span class="nav-number">9.</span> <span class="nav-text">Applying Decorators to Class and Static Methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Writing-Decorators-That-Add-Arguments-to-Wrapped-Functions"><span class="nav-number">10.</span> <span class="nav-text">Writing Decorators That Add Arguments to Wrapped Functions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-Decorators-to-Patch-Class-Definitions"><span class="nav-number">11.</span> <span class="nav-text">Using Decorators to Patch Class Definitions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-a-Metaclass-to-Control-Instance-Creation"><span class="nav-number">12.</span> <span class="nav-text">Using a Metaclass to Control Instance Creation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Capturing-Class-Attribute-Definition-Order"><span class="nav-number">13.</span> <span class="nav-text">Capturing Class Attribute Definition Order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-a-Metaclass-That-Takes-Optional-Arguments"><span class="nav-number">14.</span> <span class="nav-text">Defining a Metaclass That Takes Optional Arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enforcing-an-Argument-Signature-on-args-and-kwargs"><span class="nav-number">15.</span> <span class="nav-text">Enforcing an Argument Signature on *args and **kwargs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enforcing-Coding-Conventions-in-Classes"><span class="nav-number">16.</span> <span class="nav-text">Enforcing Coding Conventions in Classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-Classes-Programmatically"><span class="nav-number">17.</span> <span class="nav-text">Defining Classes Programmatically</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Initializing-Class-Members-at-Definition-Time"><span class="nav-number">18.</span> <span class="nav-text">Initializing Class Members at Definition Time</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-Multiple-Dispatch-with-Function-Annotations"><span class="nav-number">19.</span> <span class="nav-text">Implementing Multiple Dispatch with Function Annotations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Avoiding-Repetitive-Property-Methods"><span class="nav-number">20.</span> <span class="nav-text">Avoiding Repetitive Property Methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-Context-Managers-the-Easy-Way"><span class="nav-number">21.</span> <span class="nav-text">Defining Context Managers the Easy Way</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eustoma</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>whistlestop</title>
  
  <subtitle>Never start something you&#39;re not willing to finish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-15T06:20:28.983Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>eustoma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C01_named tuple, random.choice</title>
    <link href="http://yoursite.com/2018/04/14/C01-named-tuple-random-choice/"/>
    <id>http://yoursite.com/2018/04/14/C01-named-tuple-random-choice/</id>
    <published>2018-04-15T06:19:31.000Z</published>
    <updated>2018-04-15T06:20:28.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>Python中的tuples（元组）是经常用来表示简单的数据结构，但它只能通过下标来访问其中的数据，这导<br>致代码难于阅读和维护。Python的collections模块包含一个namedtuple()函数，用来创建一个tuple的子<br>类，其可以通过属性名称访问tuple中的元素。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>NetworkAddress = namedtuple(<span class="string">'NetworkAddress'</span>,[<span class="string">'hostname'</span>,<span class="string">'port'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = NetworkAddress(<span class="string">'www.python.org'</span>,<span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.hostname</span><br><span class="line"><span class="string">'www.python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.port</span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>host, port = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">NetworkAddress</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">isinstance</span><span class="params">(a, tuple)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure></p><p>支持所有普通tuple的操作，而且增加了通过使用属性名访问其中数据的功能。<br>但使用namedtuple访问属性值时，不如通过类那样高效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,shares,price)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.shares = shares</span><br><span class="line">self.price = price</span><br><span class="line"><span class="comment">#可定义为</span></span><br><span class="line">Stock=namedtuple(<span class="string">'Stock'</span>,[<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>])</span><br></pre></td></tr></table></figure><p>作为字典的替代，因为字典存储需要更多的内存空间。 如果你需要构建一个非常大的包含字典的数据结<br>构，那么使用命名元组会更加高效。 但是需要注意的是，不像字典那样，一个命名元组是不可更改的。</p><p>需要改变属性的值，可以使用命名元组实例的 _replace() 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">123.45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Stock(name=<span class="string">'ACME'</span>, shares=<span class="number">100</span>, price=<span class="number">123.45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shares = <span class="number">75</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">s._replace(shares=75)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; s</span></span><br><span class="line"><span class="string">Stock(name='</span>ACME<span class="string">', shares=75, price=123.45)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><h4 id="random-choice"><a href="#random-choice" class="headerlink" title="random.choice"></a>random.choice</h4><p>从一个序列中随机的抽取一个元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice(values)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice(values)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h4 id="random-sample"><a href="#random-sample" class="headerlink" title="random.sample"></a>random.sample</h4><p>提取出N个不同元素的样本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values,<span class="number">4</span>)</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values,<span class="number">3</span>)</span><br><span class="line">[<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(values,<span class="number">3</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random.shuffle"></a>random.shuffle</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(values)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(values)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="random-randint"><a href="#random-randint" class="headerlink" title="random.randint"></a>random.randint</h4><p>生成随机整数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><h4 id="random-random"><a href="#random-random" class="headerlink" title="random.random()"></a>random.random()</h4><p>生成0到1范围内均匀分布的浮点数</p><h4 id="random-getrandbits"><a href="#random-getrandbits" class="headerlink" title="random.getrandbits()"></a>random.getrandbits()</h4><p>获取N位随机位(二进制)的整数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.getrandbits(<span class="number">22</span>)</span><br><span class="line"><span class="number">343509</span></span><br></pre></td></tr></table></figure></p><h4 id="random-seed"><a href="#random-seed" class="headerlink" title="random.seed()"></a>random.seed()</h4><p>random 模块使用 Mersenne Twister 算法来计算生成随机数。这是一个确定性算法， 但是你可以通过<br>random.seed() 函数修改初始化种子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">random.seed() <span class="comment"># Seed based on system time or os.urandom()</span></span><br><span class="line">random.seed(<span class="number">12345</span>) <span class="comment"># Seed based on integer given</span></span><br><span class="line">random.seed(<span class="string">b'bytedata'</span>) <span class="comment"># Seed based on byte data</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;namedtuple&quot;&gt;&lt;a href=&quot;#namedtuple&quot; class=&quot;headerlink&quot; title=&quot;namedtuple&quot;&gt;&lt;/a&gt;namedtuple&lt;/h3&gt;&lt;p&gt;Python中的tuples（元组）是经常用来表示简单的数据结构，但它只能通过下标来访问其中的数据，这导&lt;br&gt;致代码难于阅读和维护。Python的collections模块包含一个namedtuple()函数，用来创建一个tuple的子&lt;br&gt;类，其可以通过属性名称访问tuple中的元素。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="learning python 5th" scheme="http://yoursite.com/tags/learning-python-5th/"/>
    
  </entry>
  
  <entry>
    <title>C24_CURSOR</title>
    <link href="http://yoursite.com/2018/04/14/C24-CURSOR/"/>
    <id>http://yoursite.com/2018/04/14/C24-CURSOR/</id>
    <published>2018-04-15T06:18:19.000Z</published>
    <updated>2018-04-15T06:18:40.216Z</updated>
    
    <content type="html"><![CDATA[<p>需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在<br>MySQL服务器上的数据库查询，它不是一条SELECT 语句，而是被该语句检索出来的结果集。在存储了游标<br>之后，应用程序可以根据需要滚动或浏览其中的数据。</p><p>MySQL游标只能用于存储过程（和函数）。<br><a id="more"></a><br>使用游标涉及几个明确的步骤:</p><ul><li>在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT 语句。</li><li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT 语句把数据实际检索出来。</li><li>对于填有数据的游标，根据需要取出（检索）各行。</li><li>在结束游标使用时，必须关闭游标。</li></ul><h3 id="DECLARE-CURSOR"><a href="#DECLARE-CURSOR" class="headerlink" title="DECLARE CURSOR"></a>DECLARE CURSOR</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#这个存储过程处理完成后，游标就消失（因为它局限于存储过程）。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span> # <span class="keyword">DECLARE</span> 语句用来定义和命名游标</span><br><span class="line">    <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> ordernum <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h3><p>CLOSE 释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- Declare the cursor</span></span><br><span class="line">   <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">   <span class="keyword">FOR</span></span><br><span class="line">   <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Open the cursor</span></span><br><span class="line">   OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Close the cursor</span></span><br><span class="line">   CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></p><h3 id="FETCH游标数据"><a href="#FETCH游标数据" class="headerlink" title="FETCH游标数据"></a>FETCH游标数据</h3><p>在一个游标被打开后，可以使用FETCH 语句分别访问它的每一行。FETCH 指定检索什么数据（所需的<br>列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH 语句检索下<br>一行（不重复读取同一行）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Declare local variables</span></span><br><span class="line">   <span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Declare the cursor</span></span><br><span class="line">   <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">   <span class="keyword">FOR</span></span><br><span class="line">   <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Declare continue handler</span></span><br><span class="line">   <span class="comment">-- 当SQLSTATE '02000' 出现时，SET done=1 。SQLSTATE '02000' 是一个未找到条件，当REPEAT 由于</span></span><br><span class="line">   <span class="comment">-- 没有更多的行供循环而不能继续时，出现这个条件。</span></span><br><span class="line">   <span class="comment">--- 句柄必须在游标之后定义</span></span><br><span class="line">   <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Open the cursor</span></span><br><span class="line">   OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Loop through all rows</span></span><br><span class="line">   REPEAT</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Get order number</span></span><br><span class="line">      FETCH ordernumbers INTO o;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- End of loop</span></span><br><span class="line">   UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Close the cursor</span></span><br><span class="line">   CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>下面例子中，我们增加了另一个名为t 的变量（存储每个订单的合计）。此存储过程还在运行中创建了一<br>个新表（如果它不存在的话），名为ordertotals 。这个表将保存存储过程生成的结果。FETCH 像以前一样<br>取每个order_num ，然后用CALL 执行另一个存储过程（我们在前一章中创建）来计算每个订单的带税的<br>合计（结果存储到t ）。最后，用INSERT 保存每个订单的订单号和合计。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Declare local variables</span></span><br><span class="line">   <span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> t <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Declare the cursor</span></span><br><span class="line">   <span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line">   <span class="keyword">FOR</span></span><br><span class="line">   <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line">   <span class="comment">-- Declare continue handler</span></span><br><span class="line">   <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Create a table to store the results</span></span><br><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals</span><br><span class="line">      (order_num <span class="built_in">INT</span>, total <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Open the cursor</span></span><br><span class="line">   OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Loop through all rows</span></span><br><span class="line">   REPEAT</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Get order number</span></span><br><span class="line">      FETCH ordernumbers INTO o;</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Get the total for this order</span></span><br><span class="line">      <span class="keyword">CALL</span> ordertotal(o, <span class="number">1</span>, t);</span><br><span class="line"></span><br><span class="line">      <span class="comment">-- Insert order and total into ordertotals</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> ordertotals(order_num, total)</span><br><span class="line">      <span class="keyword">VALUES</span>(o, t);</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- End of loop</span></span><br><span class="line">   UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- Close the cursor</span></span><br><span class="line">   CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在&lt;br&gt;MySQL服务器上的数据库查询，它不是一条SELECT 语句，而是被该语句检索出来的结果集。在存储了游标&lt;br&gt;之后，应用程序可以根据需要滚动或浏览其中的数据。&lt;/p&gt;
&lt;p&gt;MySQL游标只能用于存储过程（和函数）。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C23_存储过程</title>
    <link href="http://yoursite.com/2018/04/14/C23-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/04/14/C23-存储过程/</id>
    <published>2018-04-15T06:16:57.000Z</published>
    <updated>2018-04-15T06:17:47.530Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL 。CALL 接受存储过程的名字以及<br>需要传递给它的任意参数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing ( @pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br><span class="line">#执行名为productpricing 的存储过程，它计算并返回产品的最低、最高和平均价格</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="CREATR-PROCEDURE-创建存储过程"><a href="#CREATR-PROCEDURE-创建存储过程" class="headerlink" title="CREATR PROCEDURE 创建存储过程"></a>CREATR PROCEDURE 创建存储过程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">   <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">#此存储过程名为productpricing ，用CREATE PROCEDURE productpricing() 语句定义。如果存储过程接受</span><br><span class="line">#参数，它们将在() 中列举出来。</span><br></pre></td></tr></table></figure><h3 id="更改命令行分隔符"><a href="#更改命令行分隔符" class="headerlink" title="更改命令行分隔符"></a>更改命令行分隔符</h3><p>DELIMITER// 告诉命令行实用程序使用// 作为新的语句结束分隔符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">     <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line">     <span class="keyword">FROM</span> products;</span><br><span class="line">  <span class="keyword">END</span> //</span><br></pre></td></tr></table></figure></p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> productpricing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> productpricing <span class="keyword">IF</span> <span class="keyword">EXISTS</span>;</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><p>关键字OUT 指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN （传递给存储<br>过程）、OUT （从存储过程传出，如这里所用）和INOUT （对存储过程传入和传出）类型的参数。存储<br>过程的代码位于BEGIN 和END 语句内，一系列SELECT 语句，用来检索值，然后保存到相应的变量（通过<br>指定INTO 关键字）。</p><p>所有MySQL变量都必须以@ 开始。</p><h4 id="OUT-参数"><a href="#OUT-参数" class="headerlink" title="OUT 参数"></a>OUT 参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(</span><br><span class="line">   <span class="keyword">OUT</span> pl <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">   <span class="keyword">OUT</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">   <span class="keyword">OUT</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">Min</span>(prod_price)</span><br><span class="line">   <span class="keyword">INTO</span> pl</span><br><span class="line">   <span class="keyword">FROM</span> products;</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">Max</span>(prod_price)</span><br><span class="line">   <span class="keyword">INTO</span> ph</span><br><span class="line">   <span class="keyword">FROM</span> products;</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price)</span><br><span class="line">   <span class="keyword">INTO</span> pa</span><br><span class="line">   <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">#调用productpricing， 指定三个变量,</span><br><span class="line">#在调用时，这条语句并不显示任何数据。它返回以后可以显示（或在其他处理中使用）的变量。</span><br><span class="line"><span class="keyword">CALL</span> productpricing(</span><br><span class="line">@pricelow,</span><br><span class="line">@pricehigh,</span><br><span class="line">@priceaverage</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#显示检索出的产品平均价格，可如下进行：</span><br><span class="line"><span class="keyword">SELECT</span> @pricehigh, @pricelow, @priceaverage;</span><br></pre></td></tr></table></figure><h4 id="IN-OUT-参数"><a href="#IN-OUT-参数" class="headerlink" title="IN, OUT 参数"></a>IN, OUT 参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line"><span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price * quantity)</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = onumber</span><br><span class="line"><span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">#调用ordertotal, 第一个参数为订单号，第二个参数为包含计算出来的合计的变量名</span><br><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, @total);</span><br></pre></td></tr></table></figure><h3 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h3><p><code>`</code>sql</p><p>#注释 –</p><p>– Name: ordertotal<br>– Parameters: onumber = order number<br>–             taxable = 0 if not taxable, 1 if taxable<br>–             ototal = order total variable</p><p>CREATE PROCEDURE ordertotal(<br>             IN onumber INT,<br>             IN taxable BOOLEAN,<br>             OUT ototal DECIMAL(8,2)<br>) COMMENT ‘Obtain order total, optionally adding tax’ #将在SHOW PROCEDURE STATUS 的结果中显示</p><p>BEGIN</p><pre><code># DECLARE 语句定义了两个局部变量DECLARE total DECIMAL(8,2);DECLARE taxrate INT DEFAULT 6;SELECT Sum(item_price * quantity)FROM orderitemsWHERE order_num = onumberINTO total;IF taxable THEN             SELECT total + (total/100*taxrate) INTO total;END IF;SELECT total INTO ototal;</code></pre><p>END;</p><p>CALL ordertotal(20005, 1, @total);</p><h1 id="获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW-PROCEDURE-STATUS"><a href="#获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW-PROCEDURE-STATUS" class="headerlink" title="获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW PROCEDURE STATUS"></a>获得包括何时、由谁创建等详细信息的存储过程列表，使用SHOW PROCEDURE STATUS</h1><p>#使用LIKE 指定一个过滤模式<br>SHOW PROCEDURE STATUS LIKE ‘ordertotal’;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL 。CALL 接受存储过程的名字以及&lt;br&gt;需要传递给它的任意参数。&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CALL&lt;/span&gt; productpricing ( @pricelow,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    @pricehigh,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    @priceaverage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#执行名为productpricing 的存储过程，它计算并返回产品的最低、最高和平均价格&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C22_View</title>
    <link href="http://yoursite.com/2018/04/14/C22-View/"/>
    <id>http://yoursite.com/2018/04/14/C22-View/</id>
    <published>2018-04-15T06:16:00.000Z</published>
    <updated>2018-04-15T06:16:32.718Z</updated>
    
    <content type="html"><![CDATA[<p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询</p><p>在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT 操作，过滤和排序数<br>据，将视图联结到其他视图或表，甚至能添加和更新数据。</p><p>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的<br>数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。<br><a id="more"></a><br>视图的一些常见应用:</p><ul><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><p>视图的规则和限制:</p><ul><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY 可以用在视图中，但如果从该视图检索数据SELECT 中也含有ORDER BY ，那么该视图中的</li><li>ORDER BY 将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT 语句。</li></ul><h3 id="CREATE-VIEW"><a href="#CREATE-VIEW" class="headerlink" title="CREATE VIEW"></a>CREATE VIEW</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productcustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line">  <span class="keyword">AND</span> orderitems.order_num = orders.order_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendorlocations <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(vend_name), <span class="string">' ('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>)</span><br><span class="line">       <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line">#过滤</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremaillist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"># 计算字段</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> orderitemsexpanded <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems;</span><br></pre></td></tr></table></figure><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可更新的（即，可以对它们使用INSERT 、UPDATE 和DELETE ）。更新一个视图将更新其基表<br>（视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新<br>（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ul><li>分组（使用GROUP BY 和HAVING ）；</li><li>联结；</li><li>子查询；</li><li>并；</li><li>聚集函数（Min() 、Count() 、Sum() 等）；</li><li>DISTINCT ；</li><li>导出（计算）列</li></ul><p>一般，应该将视图用于检索（SELECT 语句）而不用于更新（INSERT 、UPDATE 和DELETE ）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询&lt;/p&gt;
&lt;p&gt;在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT 操作，过滤和排序数&lt;br&gt;据，将视图联结到其他视图或表，甚至能添加和更新数据。&lt;/p&gt;
&lt;p&gt;重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的&lt;br&gt;数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C21_ALTER TABLE</title>
    <link href="http://yoursite.com/2018/04/14/C21-ALTER-TABLE/"/>
    <id>http://yoursite.com/2018/04/14/C21-ALTER-TABLE/</id>
    <published>2018-04-15T06:15:11.000Z</published>
    <updated>2018-04-15T06:15:38.934Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#给表添加一个列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">#删除一个列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br><span class="line"></span><br><span class="line">#定义外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_orders</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (order_num) <span class="keyword">REFERENCES</span> orders (order_num);</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orderitems_products FOREIGN <span class="keyword">KEY</span> (prod_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> products (prod_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_orders_customers FOREIGN <span class="keyword">KEY</span> (cust_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> customers (cust_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_products_vendors</span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (vend_id) <span class="keyword">REFERENCES</span> vendors (vend_id);</span><br></pre></td></tr></table></figure><p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p><ul><li>用新的列布局创建一个新表；</li><li>使用INSERT SELECT 语句（关于这条语句的详细介绍，请参阅第19章）从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段；</li><li>检验包含所需数据的新表；</li><li>重命名旧表（如果确定，可以删除它）；</li><li>用旧表原来的名字重命名新表；</li><li>根据需要，重新创建触发器、存储过程、索引和外键。</li></ul><h3 id="DROP-TABLE"><a href="#DROP-TABLE" class="headerlink" title="DROP TABLE"></a>DROP TABLE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#删除表没有确认，也不能撤销</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> customers2;</span><br></pre></td></tr></table></figure><h3 id="RENAME-TABLE"><a href="#RENAME-TABLE" class="headerlink" title="RENAME TABLE"></a>RENAME TABLE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> backup_customers <span class="keyword">TO</span> customers,</span><br><span class="line">             backup_vendors <span class="keyword">TO</span> vendors,</span><br><span class="line">             backup_products <span class="keyword">TO</span> products;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C21_CREATE TABLE</title>
    <link href="http://yoursite.com/2018/04/14/C21-CREATE-TABLE/"/>
    <id>http://yoursite.com/2018/04/14/C21-CREATE-TABLE/</id>
    <published>2018-04-15T06:14:14.000Z</published>
    <updated>2018-04-15T06:14:50.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY (vend_id) #用单个列作为主键</span><br><span class="line"></span><br><span class="line">#创建由多个列组成的主键,应该以逗号分隔的列表给出各列名</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orderitems</span><br><span class="line">(</span><br><span class="line">  order_num  <span class="built_in">int</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  order_item <span class="built_in">int</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_id    <span class="built_in">char</span>(<span class="number">10</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  quantity   <span class="built_in">int</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  item_price <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (order_num, order_item)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><p>每个表只允许一个AUTO_INCREMENT 列，而且它必须被索引（如，通过使它成为主键）。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cust_id      int      NOT NULL AUTO_INCREMENT,</span><br><span class="line">#AUTO_INCREMENT 告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT 操作时，MySQL</span><br><span class="line">#自动对该列增量，给该列赋予下一个可用的值。这样给每个行分配一个唯一的cust_id ，从而可以用作主</span><br><span class="line">#键值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">last_insert_id</span>();</span><br><span class="line">#返回最后一个AUTO_INCREMENT 值</span><br></pre></td></tr></table></figure></p><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE 语句的列定义<br>中的DEFAULT关键字指定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantity   int          NOT NULL  DEFAULT 1,</span><br></pre></td></tr></table></figure><h3 id="ENGINE"><a href="#ENGINE" class="headerlink" title="ENGINE"></a>ENGINE</h3><p>引擎类型可以混用。混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。</p><ul><li>InnoDB 是一个可靠的事务处理引擎，它不支持全文本搜索；</li><li>MEMORY 在功能等同于MyISAM ，但由于数据存储在内存中，速度很快（特别适合于临时  表</li><li>MyISAM 是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li></ul><p><code></code>sql<br>CREATE TABLE orderitems<br>(<br>  order_num  int          NOT NULL ,<br>  order_item int          NOT NULL ,<br>  prod_id    char(10)     NOT NULL ,<br>  quantity   int          NOT NULL  DEFAULT 1,<br>  item_price decimal(8,2) NOT NULL ,<br>  PRIMARY KEY (order_num, order_item)<br>) ENGINE=InnoDB;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PRIMARY-KEY&quot;&gt;&lt;a href=&quot;#PRIMARY-KEY&quot; class=&quot;headerlink&quot; title=&quot;PRIMARY KEY&quot;&gt;&lt;/a&gt;PRIMARY KEY&lt;/h3&gt;&lt;p&gt;如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合
      
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C20_UPDATE_DELETE</title>
    <link href="http://yoursite.com/2018/04/14/C20-UPDATE-DELETE/"/>
    <id>http://yoursite.com/2018/04/14/C20-UPDATE-DELETE/</id>
    <published>2018-04-15T06:12:58.000Z</published>
    <updated>2018-04-15T06:13:39.010Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="string">'elmer@fudd.com'</span>,</span><br><span class="line">       cust_name = <span class="string">'The Fudds'</span>,</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="literal">NULL</span> #<span class="literal">NULL</span> 用来去除cust_email 列中的值。</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10005</span>;</span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h3 id="IGNORE"><a href="#IGNORE" class="headerlink" title="IGNORE"></a>IGNORE</h3><p>如果用UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE 操作<br>被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使<br>用IGNORE 关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">IGNORE</span> customers ...</span><br></pre></td></tr></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10006</span>;</span><br></pre></td></tr></table></figure><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><ul><li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE 子句的UPDATE 或DELETE 语句。</li><li>保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE 子句那样使用它（可以指</li><li>定各主键、多个值或值的范围）。</li><li>在对UPDATE 或DELETE 语句使用WHERE 子句前，应该先用SELECT 进行测试，保证它过滤的是正确的记</li><li>录，以防编写的WHERE 子句不正确。</li><li>使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章），这样MySQL将不允许删除具有与</li><li>其他表相关联的数据的行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C19_INSERT</title>
    <link href="http://yoursite.com/2018/04/14/C19-INSERT/"/>
    <id>http://yoursite.com/2018/04/14/C19-INSERT/</id>
    <published>2018-04-15T06:11:58.000Z</published>
    <updated>2018-04-15T06:12:37.064Z</updated>
    
    <content type="html"><![CDATA[<p>INSERT 是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：</p><ul><li>插入完整的行；</li><li>插入行的一部分；</li><li>插入多行；</li><li>插入某些查询的结果。<a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">   <span class="string">'100 Main Street'</span>,</span><br><span class="line">   <span class="string">'Los Angeles'</span>,</span><br><span class="line">   <span class="string">'CA'</span>,</span><br><span class="line">   <span class="string">'90046'</span>,</span><br><span class="line">   <span class="string">'USA'</span>,</span><br><span class="line">   <span class="literal">NULL</span>,</span><br><span class="line">   <span class="literal">NULL</span>);</span><br><span class="line">#插入一个新客户到customers 表。存储到每个表列中的数据在VALUES 子句中给出，对每个列必须提供一</span><br><span class="line">#个值。如果某个列没有值（如上面的cust_contact 和cust_email 列），应该使用NULL 值（假定表允许对</span><br><span class="line">#该列指定空值）。各个列必须以它们在表定义中出现的次序填充。第一列cust_id 也为NULL 。这是因为</span><br><span class="line">#每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作），又不能省略</span><br><span class="line">#此列（如前所述，必须给出每个列），所以指定一个NULL 值（它被MySQL忽略，MySQL在这里插入下</span><br><span class="line">#一个可用的cust_id 值）。</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_name,</span><br><span class="line">   cust_address,</span><br><span class="line">   cust_city,</span><br><span class="line">   cust_state,</span><br><span class="line">   cust_zip,</span><br><span class="line">   cust_country,</span><br><span class="line">   cust_contact,</span><br><span class="line">   cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">   <span class="string">'100 Main Street'</span>,</span><br><span class="line">   <span class="string">'Los Angeles'</span>,</span><br><span class="line">   <span class="string">'CA'</span>,</span><br><span class="line">   <span class="string">'90046'</span>,</span><br><span class="line">   <span class="string">'USA'</span>,</span><br><span class="line">   <span class="literal">NULL</span>,</span><br><span class="line">   <span class="literal">NULL</span>);</span><br><span class="line">#在插入行时，MySQL将用VALUES 列表中的相应值填入列表中的对应项。VALUES 中的第一个值对应于第</span><br><span class="line">#一个指定的列名。第二个值对应于第二个列名，如此等等。</span><br><span class="line"></span><br><span class="line">#因为提供了列名，VALUES 必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次</span><br><span class="line">#序。其优点是，即使表的结构改变，此INSERT 语句仍然能正确工作。你会发现cust_id 的NULL 值是不必</span><br><span class="line">#要的，cust_id 列并没有出现在列表中，所以不需要任何值。</span><br></pre></td></tr></table></figure><p>如果数据检索是最重要的（通常是这样），则你可以通过在INSERT 和INTO 之间添加关键字<br>LOW_PRIORITY ，指示MySQL降低INSERT 语句的优先级, 也适用于UPDATE 和DELETE 语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">LOW_PRIORITY</span> <span class="keyword">INTO</span></span><br></pre></td></tr></table></figure></p><h3 id="insert-多条"><a href="#insert-多条" class="headerlink" title="insert 多条"></a>insert 多条</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_name,</span><br><span class="line">   cust_address,</span><br><span class="line">   cust_city,</span><br><span class="line">   cust_state,</span><br><span class="line">   cust_zip,</span><br><span class="line">   cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(</span><br><span class="line">        <span class="string">'Pep E. LaPew'</span>,</span><br><span class="line">        <span class="string">'100 Main Street'</span>,</span><br><span class="line">        <span class="string">'Los Angeles'</span>,</span><br><span class="line">        <span class="string">'CA'</span>,</span><br><span class="line">        <span class="string">'90046'</span>,</span><br><span class="line">        <span class="string">'USA'</span></span><br><span class="line">     ),</span><br><span class="line">      (</span><br><span class="line">        <span class="string">'M. Martian'</span>,</span><br><span class="line">        <span class="string">'42 Galaxy Way'</span>,</span><br><span class="line">        <span class="string">'New York'</span>,</span><br><span class="line">        <span class="string">'NY'</span>,</span><br><span class="line">        <span class="string">'11213'</span>,</span><br><span class="line">        <span class="string">'USA'</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h3 id="INSERT-SELECT"><a href="#INSERT-SELECT" class="headerlink" title="INSERT SELECT"></a>INSERT SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers(cust_id,</span><br><span class="line">    cust_contact,</span><br><span class="line">    cust_email,</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state,</span><br><span class="line">    cust_zip,</span><br><span class="line">    cust_country)</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,</span><br><span class="line">    cust_contact,</span><br><span class="line">    cust_email,</span><br><span class="line">    cust_name,</span><br><span class="line">    cust_address,</span><br><span class="line">    cust_city,</span><br><span class="line">    cust_state,</span><br><span class="line">    cust_zip,</span><br><span class="line">    cust_country</span><br><span class="line"><span class="keyword">FROM</span> custnew;</span><br></pre></td></tr></table></figure><p>这个例子使用INSERT SELECT 从custnew 中将所有数据导入customers 。SELECT 语句从custnew 检索出要<br>插入的值，而不是列出它们。SELECT 中列出的每个列对应于customers 表名后所跟的列表中的每个列。<br>这条语句将插入多少行有赖于custnew 表中有多少行。</p><p>为简单起见，这个例子在INSERT 和SELECT 语句中使用了相同的列名。但是，不一定要求列名匹配。事实<br>上，MySQL甚至不关心SELECT 返回的列名。它使用的是列的位置，因此SELECT 中的第一列（不管其列<br>名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从<br>使用不同列名的表中导入数据是非常有用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;INSERT 是用来插入（或添加）行到数据库表的。插入可以用几种方式使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入完整的行；&lt;/li&gt;
&lt;li&gt;插入行的一部分；&lt;/li&gt;
&lt;li&gt;插入多行；&lt;/li&gt;
&lt;li&gt;插入某些查询的结果。
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C18_布尔方式 搜索_boolean mode</title>
    <link href="http://yoursite.com/2018/04/14/C18-%E5%B8%83%E5%B0%94%E6%96%B9%E5%BC%8F-%E6%90%9C%E7%B4%A2-boolean-mode/"/>
    <id>http://yoursite.com/2018/04/14/C18-布尔方式-搜索-boolean-mode/</id>
    <published>2018-04-15T06:11:04.000Z</published>
    <updated>2018-04-15T06:11:41.472Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>MySQL支持全文本搜索的另外一种形式，称为布尔方式 （boolean mode）。以布尔方式，可以提供关于如下内容的细节：<br><a id="more"></a></p><ul><li>要匹配的词；</li><li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li><li>排列提示（指定某些词比其他词更重要，更重要的词等级</li><li>表达式分组；</li><li>另外一些内容。</li></ul><p>即使没有定义FULLTEXT 索引，也可以使用它。但这是一种非常缓慢的操作</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'heavy-rope*'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line">#匹配包含heavy 但不包含任意以rope 开始的词的行, -rope* 明确地指示MySQL排除包含rope* （任何以</span><br><span class="line">#rope 开始的词，包括ropes ）的行</span><br></pre></td></tr></table></figure><ul><li>+  包含，词必须存在</li><li>-  排除，词必须不出现</li><li>> 包含，而且增加等级值</li><li>&lt; 包含，且减少等级值</li><li>()  把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</li><li>~  取消一个词的排序值</li><li>*   词尾的通配符</li><li>‘ ‘ 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'+rabbit +bait'' IN BOOLEAN MODE);</span></span><br><span class="line"><span class="string"># 搜索匹配包含词rabbit 和bait 的行</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'rabbit bait'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line">#没有指定操作符，这个搜索匹配包含rabbit 和bait 中的至少一个词的行</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">''</span>rabbit bait<span class="string">''</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line">#搜索匹配短语rabbit bait 而不是匹配两个词rabbit 和bait</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'&gt;rabbit &lt;carrot'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br><span class="line">#匹配rabbit 和carrot ，增加前者的等级，降低后者的等级</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> note_text</span><br><span class="line"><span class="keyword">FROM</span> productnotes</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Match</span>(note_text) Against(<span class="string">'+safe +(&lt;combination)'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span></span><br><span class="line"><span class="keyword">MODE</span>);</span><br><span class="line">#搜索匹配词safe 和combination ，降低后者的等级</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;MySQL支持全文本搜索的另外一种形式，称为布尔方式 （boolean mode）。以布尔方式，可以提供关于如下内容的细节：&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C18_全文本搜索</title>
    <link href="http://yoursite.com/2018/04/14/C18-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/04/14/C18-全文本搜索/</id>
    <published>2018-04-15T06:10:04.000Z</published>
    <updated>2018-04-15T06:10:45.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>一般在创建表时启用全文本搜索。CREATE TABLE 语句接受FULLTEXT 子句，它给出被索引列的一个逗号分隔<br>的列表。<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">  note_id    <span class="built_in">int</span>           <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  prod_id    <span class="built_in">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  note_date datetime       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  note_text  <span class="built_in">text</span>          <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(note_id),</span><br><span class="line">  FULLTEXT(note_text)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure></p><p>为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text) 的指示对它进行索引。这里的FULLTEXT 索引<br>单个列，如果需要也可以指定多个列。<br>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。</p><h3 id="Match-Against"><a href="#Match-Against" class="headerlink" title="Match(), Against()"></a>Match(), Against()</h3><p>在索引之后，使用两个函数Match() 和Against() 执行全文本搜索，其中Match() 指定被搜索的列，<br>Against() 指定要使用的搜索表达式</p><p>Match(note_text) 指示MySQL针对指定的列进行搜索，Against(‘rabbit’) 指定词rabbit 作为搜索文本。由于<br>有两行包含词rabbit ，这两个行被返回。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against('rabbit');</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;启用&quot;&gt;&lt;a href=&quot;#启用&quot; class=&quot;headerlink&quot; title=&quot;启用&quot;&gt;&lt;/a&gt;启用&lt;/h3&gt;&lt;p&gt;一般在创建表时启用全文本搜索。CREATE TABLE 语句接受FULLTEXT 子句，它给出被索引列的一个逗号分隔&lt;br&gt;的列表。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C16_组合查询</title>
    <link href="http://yoursite.com/2018/04/14/C16-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <id>http://yoursite.com/2018/04/14/C16-组合查询/</id>
    <published>2018-04-15T06:09:10.000Z</published>
    <updated>2018-04-15T06:09:43.430Z</updated>
    
    <content type="html"><![CDATA[<p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT 语句。MySQL也允许执行多个查询（多条<br>SELECT 语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询<br>（compoundquery）<br><a id="more"></a></p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>可用UNION 操作符来组合数条SQL查询。利用UNION ，可给出多条SELECT 语句，将它们的结果组合成单<br>个结果集。</p><ul><li>UNION 必须由两条或两条以上的SELECT 语句组成，语句之间用关键字UNION 分隔（因此，如果组合<pre><code>4条SELECT 语句，将要使用3个UNION 关键字）。</code></pre></li><li>UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列<pre><code>出）。</code></pre></li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数<pre><code>值类型或不同的日期类型）。</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span></span><br><span class="line">  <span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h3><p>UNION 从查询结果集中自动去除了重复的行, 这是UNION 的默认行为，但是如果需要，可以改变它。事<br>实上，如果想返回所有匹配行，可使用UNION ALL 而不是UNION 。如果确实需要每个条件的匹配行全部<br>出现（包括重复行），则必须使用UNION ALL 而不是WHERE 。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>SELECT 语句的输出用ORDER BY 子句排序。在用UNION 组合查询时，只能使用一条ORDER BY 子句，它必须出现在最后一条SELECT 语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY 子句。虽然ORDER BY 子句似乎只是最后一条<br>SELECT 语句的组成部分，但实际上MySQL将用它来排序所有SELECT 语句返回的所有结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT 语句。MySQL也允许执行多个查询（多条&lt;br&gt;SELECT 语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询&lt;br&gt;（compoundquery）&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C16_带聚集函数的联结</title>
    <link href="http://yoursite.com/2018/04/14/C16-%E5%B8%A6%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%9A%84%E8%81%94%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/14/C16-带聚集函数的联结/</id>
    <published>2018-04-15T06:07:58.000Z</published>
    <updated>2018-04-15T06:08:31.754Z</updated>
    
    <content type="html"><![CDATA[<p>聚集函数用来汇总数据。虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#检索所有客户及每个客户所下的订单数，下面使用了COUNT() 函数的代码可完成此工作。此SELECT 语句</span><br><span class="line">#使用INNER JOIN 将customers 和orders 表互相关联。GROUP BY 子句按客户分组数据，因此，函数调用</span><br><span class="line">#COUNT(orders.order_num) 对每个客户的订单计数，将它作为num_ord 返回</span><br><span class="line"><span class="keyword">SELECT</span> customers.cust_name,</span><br><span class="line">       customers.cust_id,</span><br><span class="line">       <span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"> <span class="keyword">ON</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure></p><pre><code class="sql"></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聚集函数用来汇总数据。虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C16_INNER JOIN, LEFT OUTER JOIN</title>
    <link href="http://yoursite.com/2018/04/14/C16-INNER-JOIN-LEFT-OUTER-JOIN/"/>
    <id>http://yoursite.com/2018/04/14/C16-INNER-JOIN-LEFT-OUTER-JOIN/</id>
    <published>2018-04-15T06:06:21.000Z</published>
    <updated>2018-04-15T06:07:29.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><p>某物品（其ID为DTNTR ）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问<br>题。此查询要求首先找到生产ID为DTNTR 的物品的供应商，然后找出这个供应商生产的其他物品<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id</span><br><span class="line">                 <span class="keyword">FROM</span> products</span><br><span class="line">                 <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</span><br><span class="line"></span><br><span class="line">#内部的SELECT语句做了一个简单的检索，返回生产ID为DTNTR 的物品供应商的vend_id 。该ID用于外部</span><br><span class="line">#查询的WHERE 子句中，以便检索出这个供应商生产的所有物品</span><br><span class="line"></span><br><span class="line">#使用联结的相同查询</span><br><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</span><br><span class="line">  <span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num, o.order_date,</span><br><span class="line">       oi.prod_id, oi.quantity, OI.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line">  <span class="keyword">AND</span> oi.order_num = o.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id = <span class="string">'FB'</span>;</span><br></pre></td></tr></table></figure><h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。</p><p>在使用OUTER JOIN 语法时，必须使用RIGHT 或LEFT 关键字指定包括其所有行的表（RIGHT 指出的是<br>OUTER JOIN 右边的表，而LEFT 指出的是OUTER JOIN 左边的表）。</p><p> 存在两种基本的外部联结形式：左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不<br>同。换句话说，左外部联结可通过颠倒FROM 或WHERE 子句中表的顺序转换为右外部联结。因此，两种<br>类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#一个简单的内部联结。它检索所有客户及其订单</span><br><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"> <span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br><span class="line"></span><br><span class="line">#检索所有客户，包括那些没有订单的客户， 使用LEFT OUTER JOIN 从FROM 子句的左边表</span><br><span class="line">#（customers 表）中选择所有行</span><br><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"> <span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自联结&quot;&gt;&lt;a href=&quot;#自联结&quot; class=&quot;headerlink&quot; title=&quot;自联结&quot;&gt;&lt;/a&gt;自联结&lt;/h3&gt;&lt;p&gt;某物品（其ID为DTNTR ）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问&lt;br&gt;题。此查询要求首先找到生产ID为DTNTR 的物品的供应商，然后找出这个供应商生产的其他物品&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysql crashcourse" scheme="http://yoursite.com/tags/mysql-crashcourse/"/>
    
  </entry>
  
  <entry>
    <title>C07_ocr.py_PIL-convert, point用法</title>
    <link href="http://yoursite.com/2018/04/14/C07-ocr-py-PIL-convert-point%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/14/C07-ocr-py-PIL-convert-point用法/</id>
    <published>2018-04-15T06:05:15.000Z</published>
    <updated>2018-04-15T06:05:49.349Z</updated>
    
    <content type="html"><![CDATA[<p>对于彩色图像，不管其图像格式是PNG，还是BMP，或者JPG，在PIL中，使用Image模块的open()函数打开后，返回的图像对象的模式都是“RGB”。而对于灰度图像，不管其图像格式是PNG，还是BMP，或者JPG，打开后，其模式为“L”。<br><a id="more"></a><br>对于PNG、BMP和JPG彩色图像格式之间的互相转换都可以通过Image模块的open()和save()函数来完成。<br>具体说就是，在打开这些图像时，PIL会将它们解码为三通道的“RGB”图像。用户可以基于这个“RGB”图<br>像，对其进行处理。处理完毕，使用函数save()，可以将处理结果保存成PNG、BMP和JPG中任何格式。这<br>样也就完成了几种格式之间的转换。同理，其他格式的彩色图像也可以通过这种方式完成转换。当然，对<br>于不同格式的灰度图像，也可通过类似途径完成，只是PIL解码后是模式为“L”的图像。</p><p>Image模块的convert()函数，用于不同模式图像之间的转换。PIL中有九种不同模式。分别为<br>1，L，P，RGB，RGBA，CMYK，YCbCr，I，F。convert()函数有三种形式的定义，它们定义形式如下：</p><ul><li>im.convert(mode) ⇒ image</li><li>im.convert(“P”, **options) ⇒ image</li><li>im.convert(mode, matrix) ⇒ image<br>使用不同的参数，将当前的图像转换为新的模式，并产生新的图像作为返回值。</li></ul><h3 id="模式“1”"><a href="#模式“1”" class="headerlink" title="模式“1”"></a>模式“1”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> PIL <span class="keyword">import</span> Image        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena =Image.open(<span class="string">"D:\\Code\\Python\\test\\img\\lena.jpg"</span>)        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena.mode        </span><br><span class="line"><span class="string">'RGB'</span>        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena.getpixel((<span class="number">0</span>,<span class="number">0</span>))  </span><br><span class="line">(<span class="number">197</span>, <span class="number">111</span>, <span class="number">78</span>)        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena_1 = lena.convert(<span class="string">"1"</span>)        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena_1.mode        </span><br><span class="line"><span class="string">'1'</span>        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena_1.size      </span><br><span class="line">(<span class="number">512</span>, <span class="number">512</span>)        </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((<span class="number">0</span>,<span class="number">0</span>))        </span><br><span class="line"><span class="number">255</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena_1.getpixel((<span class="number">10</span>,<span class="number">10</span>))        </span><br><span class="line"><span class="number">255</span>  </span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((<span class="number">10</span>,<span class="number">120</span>))  </span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;lena_1.getpixel((<span class="number">130</span>,<span class="number">120</span>))  </span><br><span class="line"><span class="number">255</span></span><br></pre></td></tr></table></figure><h3 id="模式“L”"><a href="#模式“L”" class="headerlink" title="模式“L”"></a>模式“L”</h3><p>模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。在<br>PIL中，从模式“RGB”转换为“L”模式是按照下面的公式转换的：<br>L = R <em> 299/1000 + G </em> 587/1000+ B * 114/1000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lena_L =lena.convert(<span class="string">"L"</span>)    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena_L.mode    </span><br><span class="line"><span class="string">'L'</span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lena_L.size    </span><br><span class="line">(<span class="number">512</span>, <span class="number">512</span>)    </span><br><span class="line">&gt;&gt;&gt;lena.getpixel((<span class="number">0</span>,<span class="number">0</span>))    </span><br><span class="line">(<span class="number">197</span>, <span class="number">111</span>, <span class="number">78</span>)    </span><br><span class="line">&gt;&gt;&gt;lena_L.getpixel((<span class="number">0</span>,<span class="number">0</span>))  </span><br><span class="line">  <span class="number">132</span></span><br></pre></td></tr></table></figure><h3 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h3><p>point()方法通过一个函数或者查询表对图像中的像素点进行处理</p><h4 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h4><p>im.point(table)⇒ image<br>im.point(function) ⇒ image<br>返回给定查找表对应的图像像素值的拷贝。变量table为图像的每个通道设置256个值。如果使用变量<br>function，其对应函数应该有一个参数。这个函数将对每个像素值使用一次，结果表格将应用于图像的所<br>有通道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im01 = Image.open(<span class="string">"D:\\Code\\Python\\test\\img\\test01.jpg"</span>) </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;im_point_fun = im01.point(<span class="keyword">lambda</span> i:i*<span class="number">1.2</span>+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;im_point_fun.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#图像im_point_fun比原图im01亮度增加了很多；因为lambda表达式中对原图的每个像素点的值都做了增</span></span><br><span class="line"><span class="comment">#加操作。</span></span><br></pre></td></tr></table></figure><h4 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h4><p>im.point(table,mode) ⇒ image<br>im.point(function, mode) ⇒ image<br>与定义1一样，但是它会为输出图像指定一个新的模式。这个方法可以一步将模式为“L”和“P”的图像转换为<br>模式为“1”的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im01 =Image.open(<span class="string">"D:\\Code\\Python\\test\\img\\test01.jpg"</span>)</span><br><span class="line">&gt;&gt;&gt;r,g,b = im01.split()</span><br><span class="line">&gt;&gt;&gt;r.mode</span><br><span class="line"><span class="string">'L'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im= r.point(<span class="keyword">lambda</span> x:x*<span class="number">1.3</span>+<span class="number">5</span>, <span class="string">"1"</span>)</span><br><span class="line">&gt;&gt;&gt;im.show()</span><br><span class="line">&gt;&gt;&gt;im.getpixel((<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="comment">#图像im为全白图；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im= r.point(<span class="keyword">lambda</span> x:<span class="number">1</span>, <span class="string">"1"</span>)</span><br><span class="line">&gt;&gt;&gt;im.show()</span><br><span class="line">&gt;&gt;&gt;im.getpixel((<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">#图像im为全白图；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im= r.point(<span class="keyword">lambda</span> x:x*<span class="number">0</span>, <span class="string">"1"</span>)</span><br><span class="line">&gt;&gt;&gt;im.show()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im.getpixel((<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">#图像im为全黑图；</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于彩色图像，不管其图像格式是PNG，还是BMP，或者JPG，在PIL中，使用Image模块的open()函数打开后，返回的图像对象的模式都是“RGB”。而对于灰度图像，不管其图像格式是PNG，还是BMP，或者JPG，打开后，其模式为“L”。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
  <entry>
    <title>C07_form.py_PIL</title>
    <link href="http://yoursite.com/2018/04/14/C07-form-py-PIL/"/>
    <id>http://yoursite.com/2018/04/14/C07-form-py-PIL/</id>
    <published>2018-04-15T06:04:17.000Z</published>
    <updated>2018-04-15T06:04:56.633Z</updated>
    
    <content type="html"><![CDATA[<p>PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。PIL 的更新<br>速度很慢，而且存在一些难以配置的问题，不推荐使用；而 Pillow 库则是 PIL 的一个分支，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。<br><a id="more"></a></p><h3 id="新建一个-Image-类的实例"><a href="#新建一个-Image-类的实例" class="headerlink" title="新建一个 Image 类的实例"></a>新建一个 Image 类的实例</h3><p>PIL 的主要功能定义在 Image 类当中，而 Image 类定义在同名的 Image 模块当中。使用 PIL 的功能，一般都是从新建一个 Image 类的实例开始。新建 Image 类的实例有多种方法。你可以用 Image 模块的 open() 函数打开已有的图片档案，也可以处理其它的实例，或者从零开始构建一个实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">sourceFileName = <span class="string">"source.png"</span></span><br><span class="line">avatar         = Image.open(sourceFileName)</span><br><span class="line"><span class="comment">#  open() 方法打开了 source.png 这个图像，构建了名为 avatar 的实例。如果打开失败，则会抛出</span></span><br><span class="line">IOError 异常。</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 show() 方法来查看实例。注意，PIL 会将实例暂存为一个临时文件，而后打开它。</span></span><br><span class="line">avatar.show()</span><br></pre></td></tr></table></figure><h3 id="查看实例的属性"><a href="#查看实例的属性" class="headerlink" title="查看实例的属性"></a>查看实例的属性</h3><p>Image 类的实例有 5 个属性，分别是：</p><ul><li>format: 以 string 返回图片档案的格式（JPG, PNG, BMP, None, etc.）；如果不是从打开文件得到的实<br>例，则返回 None。</li><li>mode: 以 string 返回图片的模式（RGB, CMYK, etc.）；完整的列表参见 官方说明·图片模式列表</li><li>size: 以二元 tuple 返回图片档案的尺寸 (width, height)</li><li>palette: 仅当 mode 为 P 时有效，返回 ImagePalette 示例</li><li>info: 以字典形式返回示例的信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> avatar.format, avatar.size, avatar.mode</span><br><span class="line"><span class="comment">#图片的格式 PNG、图片的大小 (400, 400) 和图片的模式 RGB</span></span><br></pre></td></tr></table></figure><h3 id="图片-IO-转换图片格式"><a href="#图片-IO-转换图片格式" class="headerlink" title="图片 IO - 转换图片格式"></a>图片 IO - 转换图片格式</h3><p>Image 模块提供了 open() 函数打开图片档案，Image 类则提供了 save() 方法将图片实例保存为图片档案。</p><p>save() 函数可以以特定的图片格式保存图片档案。比如 save(‘target.jpg’, ‘JPG’) 将会以 JPG 格式将图片示例保存为 target.jpg。不过，大多数时候也可以省略图片格式。此时，save() 方法会根据文件扩展名来选择相应的图片格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    f, e = os.path.splitext(infile)</span><br><span class="line">    outfile = f + <span class="string">".jpg"</span></span><br><span class="line">    <span class="keyword">if</span> infile != outfile:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            Image.open(infile).save(outfile)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"cannot convert"</span>, infile</span><br></pre></td></tr></table></figure><h3 id="制作缩略图"><a href="#制作缩略图" class="headerlink" title="制作缩略图"></a>制作缩略图</h3><p>Image 类的 thumbnail() 方法可以用来制作缩略图。它接受一个二元数组作为缩略图的尺寸，然后将示例<br>缩小到指定尺寸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    outfile = os.path.splitext(infile)[<span class="number">0</span>] + <span class="string">".thumbnail"</span></span><br><span class="line">    <span class="keyword">if</span> infile != outfile:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            im   = Image.open(infile)</span><br><span class="line">            x, y = im.size    <span class="comment">#用 im.size 获取原图档的尺寸</span></span><br><span class="line">            im.thumbnail((x//<span class="number">2</span>, y//<span class="number">2</span>))</span><br><span class="line">            im.save(outfile, <span class="string">"JPEG"</span>)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"cannot create thumbnail for"</span>, infile</span><br></pre></td></tr></table></figure><h3 id="剪裁图档"><a href="#剪裁图档" class="headerlink" title="剪裁图档"></a>剪裁图档</h3><p>按照 horizon 和 vertic 两个变量切割当前目录下所有图片（包括子目录）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Image <span class="keyword">as</span> img</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">imgTypes = [<span class="string">'.png'</span>,<span class="string">'.jpg'</span>,<span class="string">'.bmp'</span>]</span><br><span class="line"></span><br><span class="line">horizon = <span class="number">8</span></span><br><span class="line">vertic  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'.'</span>):</span><br><span class="line">    <span class="keyword">for</span> currentFile <span class="keyword">in</span> files:</span><br><span class="line">        crtFile = root + <span class="string">'\\'</span> + currentFile</span><br><span class="line">        <span class="keyword">if</span> crtFile[crtFile.rindex(<span class="string">'.'</span>):].lower() <span class="keyword">in</span> imgTypes:</span><br><span class="line">            crtIm = img.open(crtFile)</span><br><span class="line">            crtW, crtH = crtIm.size</span><br><span class="line">            hStep = crtW // horizon</span><br><span class="line">            vStep = crtH // vertic</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(vertic):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(horizon):</span><br><span class="line">                    crtOutFileName = crtFile[:crtFile.rindex(<span class="string">'.'</span>)] + \</span><br><span class="line">                        <span class="string">'_'</span> + str(i) + <span class="string">'_'</span> + str(j)\</span><br><span class="line">                        + crtFile[crtFile.rindex(<span class="string">'.'</span>):].lower()</span><br><span class="line">                    box = (j * hStep, i * vStep, (j + <span class="number">1</span>) * hStep, (i + <span class="number">1</span>) * vStep)</span><br><span class="line">                    cropped = crtIm.crop(box)</span><br><span class="line">                    cropped.save(crtOutFileName)</span><br></pre></td></tr></table></figure><h3 id="变形与粘贴"><a href="#变形与粘贴" class="headerlink" title="变形与粘贴"></a>变形与粘贴</h3><p>transpose() 方法可以将图片左右颠倒、上下颠倒、旋转 90°、旋转 180° 或旋转 270°。paste() 方法则可以<br>将一个 Image 示例粘贴到另一个 Image 示例上。</p><p>尝试将一张图片的左半部分截取下来，左右颠倒之后旋转 180°；将图片的右半边不作更改粘贴到左半部<br>分；最后将修改过的左半部分粘贴到右半部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">imageFName = <span class="string">'source.png'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iamge_transpose</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        Input: a Image instance</span></span><br><span class="line"><span class="string">        Output: a transposed Image instance</span></span><br><span class="line"><span class="string">        Function:</span></span><br><span class="line"><span class="string">            * switches the left and the right part of a Image instance</span></span><br><span class="line"><span class="string">            * for the left part of the original instance, flips left and right\</span></span><br><span class="line"><span class="string">                and then make it upside down.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    xsize, ysize = image.size</span><br><span class="line">    xsizeLeft    = xsize // <span class="number">2</span> <span class="comment"># while xsizeRight = xsize - xsizeLeft</span></span><br><span class="line"></span><br><span class="line">    boxLeft      = (<span class="number">0</span>, <span class="number">0</span>, xsizeLeft, ysize)</span><br><span class="line">    boxRight     = (xsizeLeft, <span class="number">0</span>, xsize, ysize)</span><br><span class="line">    boxLeftNew   = (<span class="number">0</span>, <span class="number">0</span>, xsize - xsizeLeft, ysize)</span><br><span class="line">    boxRightNew  = (xsize - xsizeLeft, <span class="number">0</span>, xsize, ysize)</span><br><span class="line"></span><br><span class="line">    partLeft     = image.crop(boxLeft).transpose(Image.FLIP_LEFT_RIGHT).\</span><br><span class="line">        transpose(Image.ROTATE_180)</span><br><span class="line">    partRight    = image.crop(boxRight)</span><br><span class="line"></span><br><span class="line">    image.paste(partRight, boxLeftNew)</span><br><span class="line">    image.paste(partLeft, boxRightNew)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">avatar = Image.open(imageFName)</span><br><span class="line">avatar = iamge_transpose(avatar)</span><br><span class="line">avatar.show()</span><br></pre></td></tr></table></figure><p>以 xsize 和 ysize 接收图片的宽和高，然后以 xsizeLeft 计算得到左半边图片的大小。需要注意的是，我们构建了四个元组，并命名为盒子。这个盒子用直角坐标的值在 image 的画布上框定了一个区域。注意，Image 模块以图片的左上角为直角坐标原点，向右为 x 轴正方向，向下为 y 轴正方向。元组中的前两个数，代表区域左上角的坐标值；后两个数代表区域右下角的坐标值。</p><p>接下来的代码相当易懂。我们先用 crop() 方法将原图 boxLeft 的区域（也就是原图的左半边）切下来，然后用 transpose() 方法先后进行左右颠倒和旋转 180° 的工作，并最周公将它保存在 partLeft 这个实例中。而 partRight 的操作更为简单。</p><p>函数的最后，我们用 paste() 方法，将前两步得到的 partLeft 和 partRight 分别粘贴到指定的区域；并最终返回 image 示例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。PIL 的更新&lt;br&gt;速度很慢，而且存在一些难以配置的问题，不推荐使用；而 Pillow 库则是 PIL 的一个分支，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
  <entry>
    <title>C06_login.py_glob</title>
    <link href="http://yoursite.com/2018/04/14/C06-login-py-glob/"/>
    <id>http://yoursite.com/2018/04/14/C06-login-py-glob/</id>
    <published>2018-04-15T06:03:25.000Z</published>
    <updated>2018-04-15T06:03:57.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>glob.glob（pathname), 返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。<a id="more"></a></li><li>glob.iglob(pathname), 获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。与glob.glob()的区别是：glob.glob同时获取所有的匹配路径，而glob.iglob一次只获取一个匹配路径。</li><li>列出子目录中的文件，必须把子目录包含在模式中。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all py files</span></span><br><span class="line">files = glob.glob(<span class="string">'*.py'</span>)</span><br><span class="line"><span class="keyword">print</span> files</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ['arg.py', 'g.py', 'shut.py', 'test.py']</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it, glob</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_file_types</span><span class="params">(*patterns)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> it.chain.from_iterable(glob.glob(pattern) <span class="keyword">for</span> pattern <span class="keyword">in</span> patterns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> multiple_file_types(<span class="string">"*.txt"</span>, <span class="string">"*.py"</span>): <span class="comment"># add as many filetype arguements</span></span><br><span class="line">    <span class="keyword">print</span> filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment">#=========#</span></span><br><span class="line"><span class="comment"># test.txt</span></span><br><span class="line"><span class="comment"># arg.py</span></span><br><span class="line"><span class="comment"># g.py</span></span><br><span class="line"><span class="comment"># shut.py</span></span><br><span class="line"><span class="comment"># test.py</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it, glob, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_file_types</span><span class="params">(*patterns)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> it.chain.from_iterable(glob.glob(pattern) <span class="keyword">for</span> pattern <span class="keyword">in</span> patterns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> multiple_file_types(<span class="string">"*.txt"</span>, <span class="string">"*.py"</span>): <span class="comment"># add as many filetype arguements</span></span><br><span class="line">    realpath = os.path.realpath(filename)</span><br><span class="line">    <span class="keyword">print</span> realpath</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment">#=========#</span></span><br><span class="line"><span class="comment"># C:\xxx\pyfunc\test.txt</span></span><br><span class="line"><span class="comment"># C:\xxx\pyfunc\arg.py</span></span><br><span class="line"><span class="comment"># C:\xxx\pyfunc\g.py</span></span><br><span class="line"><span class="comment"># C:\xxx\pyfunc\shut.py</span></span><br><span class="line"><span class="comment"># C:\xxx\pyfunc\test.py</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;glob.glob（pathname), 返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
  <entry>
    <title>C05_search2.py_csv</title>
    <link href="http://yoursite.com/2018/04/14/C05-search2-py-csv/"/>
    <id>http://yoursite.com/2018/04/14/C05-search2-py-csv/</id>
    <published>2018-04-15T06:02:12.000Z</published>
    <updated>2018-04-15T06:02:49.264Z</updated>
    
    <content type="html"><![CDATA[<p>对于大多数的CSV格式的数据读写问题，都可以使用 csv 库。 例如：假设你在一个名叫stocks.csv文件中有一些股票市场数据，就像这样：<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Symbol,Price,Date,Time,Change,Volume</span><br><span class="line"><span class="string">"AA"</span>,<span class="number">39.48</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.18</span>,<span class="number">181800</span></span><br><span class="line"><span class="string">"AIG"</span>,<span class="number">71.38</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.15</span>,<span class="number">195500</span></span><br><span class="line"><span class="string">"AXP"</span>,<span class="number">62.58</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.46</span>,<span class="number">935000</span></span><br><span class="line"><span class="string">"BA"</span>,<span class="number">98.31</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,+<span class="number">0.12</span>,<span class="number">104800</span></span><br><span class="line"><span class="string">"C"</span>,<span class="number">53.08</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.25</span>,<span class="number">360900</span></span><br><span class="line"><span class="string">"CAT"</span>,<span class="number">78.29</span>,<span class="string">"6/11/2007"</span>,<span class="string">"9:36am"</span>,<span class="number">-0.23</span>,<span class="number">225400</span></span><br></pre></td></tr></table></figure></p><h3 id="读取csv数据"><a href="#读取csv数据" class="headerlink" title="读取csv数据"></a>读取csv数据</h3><h4 id="row-0-访问Symbol，-row-4-访问Change"><a href="#row-0-访问Symbol，-row-4-访问Change" class="headerlink" title="row[0] 访问Symbol， row[4] 访问Change"></a>row[0] 访问Symbol， row[4] 访问Change</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f,delimiter=<span class="string">'\t'</span>)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        <span class="comment"># Process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="row-Symbol-和-row-Change-代替下标访问"><a href="#row-Symbol-和-row-Change-代替下标访问" class="headerlink" title="row.Symbol 和 row.Change 代替下标访问"></a>row.Symbol 和 row.Change 代替下标访问</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stock.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headings = [ re.sub(<span class="string">'[^a-zA-Z_]'</span>, <span class="string">'_'</span>, h) <span class="keyword">for</span> h <span class="keyword">in</span> next(f_csv) <span class="comment">#可能有一个包含非法标识符的列头行</span></span><br><span class="line">    Row = namedtuple(<span class="string">'Row'</span>, headings)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        <span class="comment"># Process row</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者 row['Symbol']， row['Change']</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictReader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        <span class="comment"># process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="csv-DictReader-csv-DictWriter用法"><a href="#csv-DictReader-csv-DictWriter用法" class="headerlink" title="csv.DictReader, csv.DictWriter用法"></a>csv.DictReader, csv.DictWriter用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FIELDS = [<span class="string">'Name'</span>, <span class="string">'Sex'</span>, <span class="string">'E-mail'</span>, <span class="string">'Blog'</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># DictWriter  </span></span><br><span class="line">csv_file = open(<span class="string">'test.csv'</span>, <span class="string">'wb'</span>)  </span><br><span class="line">writer = csv.DictWriter(csv_file, fieldnames=FIELDS)  </span><br><span class="line"><span class="comment"># write header  </span></span><br><span class="line">writer.writerow(dict(zip(FIELDS, FIELDS)))  </span><br><span class="line">  </span><br><span class="line">d = &#123;&#125;  </span><br><span class="line">d[<span class="string">'Name'</span>] = <span class="string">'Qi'</span>  </span><br><span class="line">d[<span class="string">'Sex'</span>] = <span class="string">'Male'</span>  </span><br><span class="line">d[<span class="string">'E-mail'</span>] = <span class="string">'redice@163.com'</span>  </span><br><span class="line">d[<span class="string">'Blog'</span>] = <span class="string">'http://www.redicecn.com'</span>  </span><br><span class="line">  </span><br><span class="line">writer.writerow(d)  </span><br><span class="line">csv_file.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># DictReader  </span></span><br><span class="line"><span class="comment"># A easier way for skipping the header  </span></span><br><span class="line"><span class="comment"># Usually we need a extra flag variables  </span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> csv.DictReader(open(<span class="string">'test.csv'</span>, <span class="string">'rb'</span>)):  </span><br><span class="line">    <span class="keyword">print</span> d  </span><br><span class="line"><span class="comment"># Output:  </span></span><br><span class="line"><span class="comment"># &#123;'Blog': 'http://www.redicecn.com', 'E-mail': 'redice@163.com', 'Name': 'Qi', 'Sex': 'Male'&#125;</span></span><br></pre></td></tr></table></figure><h3 id="写入csv数据"><a href="#写入csv数据" class="headerlink" title="写入csv数据"></a>写入csv数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#创建writer对象</span></span><br><span class="line">headers = [<span class="string">'Symbol'</span>,<span class="string">'Price'</span>,<span class="string">'Date'</span>,<span class="string">'Time'</span>,<span class="string">'Change'</span>,<span class="string">'Volume'</span>]</span><br><span class="line">rows = [(<span class="string">'AA'</span>, <span class="number">39.48</span>, <span class="string">'6/11/2007'</span>, <span class="string">'9:36am'</span>, <span class="number">-0.18</span>, <span class="number">181800</span>),</span><br><span class="line">         (<span class="string">'AIG'</span>, <span class="number">71.38</span>, <span class="string">'6/11/2007'</span>, <span class="string">'9:36am'</span>, <span class="number">-0.15</span>, <span class="number">195500</span>),</span><br><span class="line">         (<span class="string">'AXP'</span>, <span class="number">62.58</span>, <span class="string">'6/11/2007'</span>, <span class="string">'9:36am'</span>, <span class="number">-0.46</span>, <span class="number">935000</span>),</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerows(rows)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建DictWriter对象</span></span><br><span class="line">headers = [<span class="string">'Symbol'</span>, <span class="string">'Price'</span>, <span class="string">'Date'</span>, <span class="string">'Time'</span>, <span class="string">'Change'</span>, <span class="string">'Volume'</span>]</span><br><span class="line">rows = [&#123;<span class="string">'Symbol'</span>:<span class="string">'AA'</span>, <span class="string">'Price'</span>:<span class="number">39.48</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:<span class="number">-0.18</span>, <span class="string">'Volume'</span>:<span class="number">181800</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AIG'</span>, <span class="string">'Price'</span>: <span class="number">71.38</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:<span class="number">-0.15</span>, <span class="string">'Volume'</span>: <span class="number">195500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AXP'</span>, <span class="string">'Price'</span>: <span class="number">62.58</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:<span class="number">-0.46</span>, <span class="string">'Volume'</span>: <span class="number">935000</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictWriter(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure><h3 id="csv数据进行类型转换"><a href="#csv数据进行类型转换" class="headerlink" title="csv数据进行类型转换"></a>csv数据进行类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">field_types = [ (<span class="string">'Price'</span>, float),</span><br><span class="line">                (<span class="string">'Change'</span>, float),</span><br><span class="line">                (<span class="string">'Volume'</span>, int) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> csv.DictReader(f):</span><br><span class="line">        row.update((key, conversion(row[key]))</span><br><span class="line">                <span class="keyword">for</span> key, conversion <span class="keyword">in</span> field_types)</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于大多数的CSV格式的数据读写问题，都可以使用 csv 库。 例如：假设你在一个名叫stocks.csv文件中有一些股票市场数据，就像这样：&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
  <entry>
    <title>C04_process_test.py_multiprocessing</title>
    <link href="http://yoursite.com/2018/04/14/C04-process-test-py-multiprocessing/"/>
    <id>http://yoursite.com/2018/04/14/C04-process-test-py-multiprocessing/</id>
    <published>2018-04-15T06:01:05.000Z</published>
    <updated>2018-04-15T06:01:50.101Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> multiprocessing是Python的标准模块，它既可以用来编写多进程，也可以用来编写多线程。如果是多线程的话，用multiprocessing.dummy即可。<br>　　如果每个子进程执行需要消耗的时间非常短（执行+1操作等），这不必使用多进程，因为进程的启动关闭也会耗费资源。<br><a id="more"></a><br>　　当然使用多进程往往是用来处理CPU密集型（科学计算）的需求，如果是IO密集型（文件读取，爬虫等）则可以使用多线程去处理。</p></blockquote><h3 id="创建管理进程模块："><a href="#创建管理进程模块：" class="headerlink" title="创建管理进程模块："></a>创建管理进程模块：</h3><ul><li>Process（用于创建进程模块）</li><li>Pool（用于创建管理进程池）</li><li>Queue（用于进程通信，资源共享）</li><li>Value，Array（用于进程通信，资源共享）</li><li>Pipe（用于管道通信）</li><li>Manager（用于资源共享）</li></ul><h3 id="同步子进程模块："><a href="#同步子进程模块：" class="headerlink" title="同步子进程模块："></a>同步子进程模块：</h3><ul><li>Condition</li><li>Event</li><li>Lock</li><li>RLock</li><li>Semaphore</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; multiprocessing是Python的标准模块，它既可以用来编写多进程，也可以用来编写多线程。如果是多线程的话，用multiprocessing.dummy即可。&lt;br&gt;　　如果每个子进程执行需要消耗的时间非常短（执行+1操作等），这不必使用多进程，因为进程的启动关闭也会耗费资源。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
  <entry>
    <title>C04_threaded_crawler.py_threading</title>
    <link href="http://yoursite.com/2018/04/14/C04-threaded-crawler-py-threading/"/>
    <id>http://yoursite.com/2018/04/14/C04-threaded-crawler-py-threading/</id>
    <published>2018-04-15T05:59:42.000Z</published>
    <updated>2018-04-15T06:00:41.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建threading-Thread的子类来包装一个线程对象"><a href="#创建threading-Thread的子类来包装一个线程对象" class="headerlink" title="创建threading.Thread的子类来包装一个线程对象"></a>创建threading.Thread的子类来包装一个线程对象</h3><blockquote><p>threading.Thread类的使用：</p></blockquote><blockquote><p>1，在自己的线程类的<strong>init</strong>里调用threading.Thread.<strong>init</strong>(self, name = threadname)  Threadname为线程的名字<br><a id="more"></a><br>2， run()，通常需要重写，编写代码实现做需要的功能。</p></blockquote><blockquote><p>3，getName()，获得线程对象名称</p></blockquote><blockquote><p>4，setName()，设置线程对象名称</p></blockquote><blockquote><p>5，start()，启动线程</p></blockquote><blockquote><p>6，join([timeout])，等待另一线程结束后再运行。</p></blockquote><blockquote><p>7，setDaemon(bool)，设置子线程是否随主线程一起结束，必须在start()之前调用。默认为False。</p></blockquote><blockquote><p>8，isDaemon()，判断线程是否随主线程一起结束。</p></blockquote><blockquote><p>9，isAlive()，检查线程是否在运行中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timer</span><span class="params">(threading.Thread)</span>:</span> <span class="comment">#The timer class is derived from the class threading.Thread</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num, interval)</span>:</span> </span><br><span class="line">        threading.Thread.__init__(self) </span><br><span class="line">        self.thread_num = num </span><br><span class="line">        self.interval = interval </span><br><span class="line">        self.thread_stop = <span class="keyword">False</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span> <span class="comment">#Overwrite run() method, put what you want the thread do here </span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.thread_stop: </span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Thread Object(%d), Time:%s\n'</span> %(self.thread_num, time.ctime()) </span><br><span class="line">            time.sleep(self.interval) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.thread_stop = <span class="keyword">True</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span> </span><br><span class="line">    thread1 = timer(<span class="number">1</span>, <span class="number">1</span>) </span><br><span class="line">    thread2 = timer(<span class="number">2</span>, <span class="number">2</span>) </span><br><span class="line">    thread1.start() </span><br><span class="line">    thread2.start() </span><br><span class="line">    time.sleep(<span class="number">10</span>) </span><br><span class="line">    thread1.stop() </span><br><span class="line">    thread2.stop() </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line">假设两个线程对象t1和t2都要对num=<span class="number">0</span>进行增<span class="number">1</span>运算，t1和t2都各对num修改<span class="number">10</span>次，num的最终的结果应</span><br><span class="line">该为<span class="number">20</span>。但是由于是多线程访问，有可能出现下面情况：在num=<span class="number">0</span>时，t1取得num=<span class="number">0</span>。系统此时把t1调</span><br><span class="line">度为”sleeping”状态，把t2转换为”running”状态，t2页获得num=<span class="number">0</span>。然后t2对得到的值进行加<span class="number">1</span>并赋给</span><br><span class="line">num，使得num=<span class="number">1</span>。然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的<span class="number">0</span>加</span><br><span class="line"><span class="number">1</span>后赋值给num。这样，明明t1和t2都完成了<span class="number">1</span>次加<span class="number">1</span>工作，但结果仍然是num=<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">上面的case描述了多线程情况下最常见的问题之一：数据共享。当多个线程都要去修改某一个共享数据的</span><br><span class="line">时候，我们需要对数据访问进行同步。</span><br></pre></td></tr></table></figure><h3 id="简单的同步"><a href="#简单的同步" class="headerlink" title="简单的同步"></a>简单的同步</h3><blockquote><p>最简单的同步机制就是“锁”。锁对象由threading.RLock类创建。线程可以使用锁的acquire()方法获得锁，<br>这样锁就进入“locked”状态。每次只有一个线程可以获得锁。如果当另一个线程试图获得这个锁的时候，<br>就会被系统变为“blocked”状态，直到那个拥有锁的线程调用锁的release()方法来释放锁，这样锁就会进<br>入“unlocked”状态。“blocked”状态的线程就会收到一个通知，并有权利获得锁。如果多个线程处于<br>“blocked”状态，所有线程都会先解除“blocked”状态，然后系统选择一个线程来获得锁，其他的线程继续<br>沉默（“blocked”）。</p></blockquote><blockquote><p>Python的threading module是在建立在thread module基础之上的一个module，在threading module中，<br>暴露了许多thread module中的属性。在thread module中，python提供了用户级的线程同步工具“Lock”<br>对象。而在threading module中，python又提供了Lock对象的变种: RLock对象。RLock对象内部维护着<br>一个Lock对象，它是一种可重入的对象。对于Lock对象而言，如果一个线程连续两次进行acquire操作，<br>那么由于第一次acquire之后没有release，第二次acquire将挂起线程。这会导致Lock对象永远不会<br>release，使得线程死锁。RLock对象允许一个线程多次对其进行acquire操作，因为在其内部通过一个<br>counter变量维护着线程acquire的次数。而且每一次的acquire操作必须有一个release操作与之对应，在<br>所有的release操作完成之后，别的线程才能申请该RLock对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mylock=threading.RLock()</span><br><span class="line">num=<span class="number">0</span></span><br><span class="line">f=file(<span class="string">'test_result.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span><span class="params">(theading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">         theading.Thread,__init__(self)</span><br><span class="line">         self.name=name</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        <span class="keyword">while</span> num&lt;=<span class="number">5</span>:</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            mylock.acquire()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Th(%s) locked, number: %d\n"</span> %(self.name, num)</span><br><span class="line">            f.write(self.name+<span class="string">" "</span>+str(num)+<span class="string">'\n'</span>)   </span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Th(%s) released, number: %d\n"</span> %(self.name, num)</span><br><span class="line">            mylock.release()</span><br><span class="line">            num += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="条件同步"><a href="#条件同步" class="headerlink" title="条件同步"></a>条件同步</h3><blockquote><p>锁只能提供最基本的同步。假如只在发生某些事件时才访问一个“临界区”，这时需要使用条件变量  Condition。Condition对象是对Lock对象的包装，在创建Condition对象时，其构造函数需要一个Lock对象作为参数，如果没有这个Lock对象参数，Condition将在内部自行创建一个Rlock对象。在Condition对象上，当然也可以调用acquire和release操作，因为内部的Lock对象本身就支持这些操作。但是Condition的价值在于其提供的wait和notify的语义。</p></blockquote><blockquote><p>　　条件变量是如何工作的呢？首先一个线程成功获得一个条件变量后，调用此条件变量的wait()方法会  导致这个线程释放这个锁，并进入“blocked”状态，直到另一个线程调用同一个条件变量的notify()方法来唤醒那个进入“blocked”状态的线程。如果调用这个条件变量的notifyAll()方法的话就会唤醒所有的在等待的线程。</p></blockquote><blockquote><p>　　如果程序或者线程永远处于“blocked”状态的话，就会发生死锁。所以如果使用了锁、条件变量等同步机制的话，一定要注意仔细检查，防止死锁情况的发生。对于可能产生异常的临界区要使用异常处理机制中的finally子句来保证释放锁。等待一个条件变量的线程必须用notify()方法显式的唤醒，否则就永远沉默。保证每一个wait()方法调用都有一个相对应的notify()调用，当然也可以调用notifyAll()方法以防万一。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">con = threading.Condition()</span><br><span class="line">x=<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        con.acquire()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> x&gt;<span class="number">0</span>:</span><br><span class="line">            con.wait()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"producing... "</span>+str(x)</span><br><span class="line">            con.notify()</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line"> </span><br><span class="line">        con.release()</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.name = name</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        con.acquire()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"consumer wait"</span></span><br><span class="line">            con.wait()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"consuming... "</span>+str(x)</span><br><span class="line">            con.notify()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line"> </span><br><span class="line">        con.release()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"start consumer\n"</span></span><br><span class="line">    th1 = Consumer(<span class="string">"consumer"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"start producer\n"</span></span><br><span class="line">    th2 = Producer(<span class="string">"producer"</span>)</span><br><span class="line"> </span><br><span class="line">    th1.start()</span><br><span class="line">    th2.start()</span><br><span class="line"> </span><br><span class="line">    th1.join()</span><br><span class="line">    th2.join()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><blockquote><p>Python中的Queue对象也提供了对线程同步的支持。使用Queue对象可以实现多个生产者和多个消费  者形成的FIFO的队列。</p></blockquote><blockquote><p>生产者将数据依次存入队列，消费者依次从队列中取出数据。  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="comment">#producer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.data = queue</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s is producing %d to the queue!\n"</span> %(self.getName(), i)</span><br><span class="line">            self.data.put(i)</span><br><span class="line">            time.sleep(random.randrange(<span class="number">10</span>)/<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"%s finished!\n"</span> %(self.getName())</span><br><span class="line"> </span><br><span class="line"><span class="comment">#consumer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.data = queue</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            something = self.data.get()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s is consuming. %d in the queue is consumed!\n"</span> %(self.getName(), something)</span><br><span class="line">            time.sleep(random.randrange(<span class="number">10</span>))</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"%s finished!\n"</span> %(self.getName())</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    queue = Queue.Queue()</span><br><span class="line">    th1 = Producer(queue)</span><br><span class="line">    th2 = Consumer(queue)</span><br><span class="line">     </span><br><span class="line">    th1.start()</span><br><span class="line">    th2.start()</span><br><span class="line"> </span><br><span class="line">    th1.join()</span><br><span class="line">    th2.join()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"all threads terminate!\n"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h3 id="join的用法"><a href="#join的用法" class="headerlink" title="join的用法"></a>join的用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">context</span><span class="params">(tJoin)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'in threadContext.'</span></span><br><span class="line">    tJoin.start()</span><br><span class="line">    <span class="comment"># 将阻塞tContext直到threadJoin终止。</span></span><br><span class="line">    tJoin.join()</span><br><span class="line">    <span class="comment"># tJoin终止后继续执行。</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'out threadContext.'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'in threadJoin.'</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'out threadJoin.'</span></span><br><span class="line"></span><br><span class="line">tJoin = threading.Thread(target=join)</span><br><span class="line">tContext = threading.Thread(target=context, args=(tJoin,))</span><br><span class="line">tContext.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果：</span></span><br><span class="line"><span class="keyword">in</span> threadContext.</span><br><span class="line"><span class="keyword">in</span> threadJoin.</span><br><span class="line">out threadJoin.</span><br><span class="line">out threadContext.</span><br><span class="line"></span><br><span class="line">&gt; tContext = threading.Thread(target=context, args=(tJoin,))</span><br><span class="line">&gt; tContext.start()</span><br><span class="line"><span class="comment"># tJoin = threading.Thread(target=join)执行后，只是创建了一个线程对象tJoin，但并未启动该线程,这两</span></span><br><span class="line"><span class="comment"># 句执行后，创建了另一个线程对象tContext并启动该线程（打印in threadContext.），同时将tJoin线程</span></span><br><span class="line"><span class="comment"># 对象作为参数传给context函数，在context函数中，启动了tJoin这个线程，同时该线程又调用了join()函</span></span><br><span class="line"><span class="comment"># 数（tJoin.join()），那tContext线程将等待tJoin这线程执行完成后，才能继续tContext线程后面的，所以</span></span><br><span class="line"><span class="comment"># 先执行join()函数,tJoin线程执行结束后，继续执行tContext线程，于是打印输出了out threadContext.，</span></span><br><span class="line"><span class="comment"># 于是就看到我们上面看到的输出结果，并且无论执行多少次，结果都是这个顺序。但如果将context()函</span></span><br><span class="line"><span class="comment"># 数中tJoin.join()这句注释掉，再执行该程序，打印输出的结果顺序就不定了，因为此时这两线程就是并</span></span><br><span class="line"><span class="comment"># 发执行的。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建threading-Thread的子类来包装一个线程对象&quot;&gt;&lt;a href=&quot;#创建threading-Thread的子类来包装一个线程对象&quot; class=&quot;headerlink&quot; title=&quot;创建threading.Thread的子类来包装一个线程对象&quot;&gt;&lt;/a&gt;创建threading.Thread的子类来包装一个线程对象&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;threading.Thread类的使用：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;1，在自己的线程类的&lt;strong&gt;init&lt;/strong&gt;里调用threading.Thread.&lt;strong&gt;init&lt;/strong&gt;(self, name = threadname)  Threadname为线程的名字&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
  <entry>
    <title>C03_disk_cached.py_shutil</title>
    <link href="http://yoursite.com/2018/04/14/C03-disk-cached-py-shutil/"/>
    <id>http://yoursite.com/2018/04/14/C03-disk-cached-py-shutil/</id>
    <published>2018-04-15T05:58:14.000Z</published>
    <updated>2018-04-15T05:59:04.544Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>os模块提供了对目录或者文件的新建/删除/查看文件属性，还提供了对文件以及目录的路径操作。比如说：绝对路径，父目录……  但是，os文件的操作还应该包含移动 复制  打包 压缩 解压等操作，这些os模块都没有提供，shutil则就是对os中文件操作的补充， shutil是shell utility的缩写。<br><a id="more"></a></p></blockquote><h3 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h3><p>shutil.copyfile( src, dst) 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉<br>shutil.move( src, dst)  移动文件或重命名<br>shutil.copymode( src, dst) 只是会复制其权限其他的东西是不会被复制的<br>shutil.copystat( src, dst) 复制权限、最后访问时间、最后修改时间<br>shutil.copy( src, dst)  复制一个文件到一个文件或一个目录<br>shutil.copy2( src, dst)  在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西<br>shutil.copy2( src, dst)  如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作<br>shutil.copytree( olddir, newdir, True/Flase)<br>把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接<br>shutil.rmtree( src ) 递归删除一个目录以及目录内的所有内容</p><h3 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h3><p>os.sep 可以取代操作系统特定的路径分隔符。windows下为 ‘\‘<br>os.name 字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是 ‘posix’<br>os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径<br>os.getenv() 获取一个环境变量，如果没有返回none<br>os.putenv(key, value) 设置一个环境变量值<br>os.listdir(path) 返回指定目录下的所有文件和目录名<br>os.remove(path) 函数用来删除一个文件<br>os.system(command) 函数用来运行shell命令<br>os.linesep 字符串给出当前平台使用的行终止符。例如，Windows使用 ‘\r\n’，Linux使用 ‘\n’ 而Mac使用 ‘\r’<br>os.path.split(path)  函数返回一个路径的目录名和文件名<br>os.path.isfile() 和os.path.isdir()函数分别检验给出的路径是一个文件还是目录<br>os.path.exists() 函数用来检验给出的路径是否真地存在<br>os.curdir  返回当前目录 (‘.’)<br>os.mkdir(path) 创建一个目录<br>os.makedirs(path) 递归的创建目录<br>os.chdir(dirname) 改变工作目录到dirname<br>os.path.getsize(name) 获得文件大小，如果name是目录返回0L<br>os.path.abspath(name) 获得绝对路径<br>os.path.normpath(path) 规范path字符串形式<br>os.path.splitext()  分离文件名与扩展名<br>os.path.join(path,name) 连接目录与文件名或目录<br>os.path.basename(path) 返回文件名<br>os.path.dirname(path) 返回文件路径<br>os.walk(top,topdown=True,onerror=None)  遍历迭代目录<br>os.rename(src, dst)  重命名file或者directory src到dst 如果dst是一个存在的directory, 将抛出OSError. 在Unix, 如果dst在存且是一个file, 如果用户有权限的话，它将被安静的替换. 操作将会失败在某些Unix 中如果src和dst在不同的文件系统中. 如果成功, 这命名操作将会是一个原子操作 (这是POSIX 需要). 在 Windows上, 如果dst已经存在, 将抛出OSError，即使它是一个文件. 在unix，Windows中有效。<br>os.renames(old, new) 递归重命名文件夹或者文件。像rename()</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;os模块提供了对目录或者文件的新建/删除/查看文件属性，还提供了对文件以及目录的路径操作。比如说：绝对路径，父目录……  但是，os文件的操作还应该包含移动 复制  打包 压缩 解压等操作，这些os模块都没有提供，shutil则就是对os中文件操作的补充， shutil是shell utility的缩写。&lt;br&gt;
    
    </summary>
    
      <category term="book notes" scheme="http://yoursite.com/categories/book-notes/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="web scraper" scheme="http://yoursite.com/tags/web-scraper/"/>
    
  </entry>
  
</feed>
